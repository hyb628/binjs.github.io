<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一喵呜</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hyb628.github.io/"/>
  <updated>2017-07-06T03:34:43.000Z</updated>
  <id>https://hyb628.github.io/</id>
  
  <author>
    <name>一喵呜</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试题：让javascript函数仅执行一次</title>
    <link href="https://hyb628.github.io/2017/06/28/%E8%AE%A9javascript%E5%87%BD%E6%95%B0%E4%BB%85%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1/"/>
    <id>https://hyb628.github.io/2017/06/28/让javascript函数仅执行一次/</id>
    <published>2017-06-28T01:55:08.000Z</published>
    <updated>2017-07-06T03:34:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>题目是这样的：<br>function a() {}<br>a();<br>a();<br>多次调用的时候 只让它执行一次。</p>
</blockquote>
<h6 id="lodash-one-的实现"><a href="#lodash-one-的实现" class="headerlink" title="lodash.one 的实现"></a>lodash.one 的实现</h6><script async src="//jsfiddle.net/hyb628/h41tx68s/embed/js/"></script>

<h5 id="另一种实现"><a href="#另一种实现" class="headerlink" title="另一种实现"></a>另一种实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function once(fn, context) &#123; </div><div class="line">    var result;</div><div class="line"> </div><div class="line">    return function() &#123; </div><div class="line">        if(fn) &#123;</div><div class="line">            result = fn.apply(context || this, arguments);</div><div class="line">            fn = null;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        return result;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// Usage</div><div class="line">var canOnlyFireOnce = once(function() &#123;</div><div class="line">    console.log(&apos;Fired!&apos;);</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">canOnlyFireOnce(); // &quot;Fired!&quot;</div><div class="line">canOnlyFireOnce(); // nothing</div></pre></td></tr></table></figure>
<h5 id="或者是"><a href="#或者是" class="headerlink" title="或者是"></a>或者是</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function test () &#123;console.log(&apos;test&apos;)&#125;</div><div class="line"></div><div class="line">var once = function (fn) &#123;</div><div class="line">  var isFirst = true;</div><div class="line">  return function () &#123;</div><div class="line">    if (isFirst) &#123;</div><div class="line">      isFirst = !isFirst;</div><div class="line">      fn();</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var b = once(test);</div><div class="line">b(); // &apos;test&apos;</div><div class="line">b(); // nothing</div></pre></td></tr></table></figure>
<p>其实实现的原理还是通过闭包的形式 通过一个flag标志来记录是否被调用过， 有的话就标记为true 然后再置为false这样的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目是这样的：&lt;br&gt;function a() {}&lt;br&gt;a();&lt;br&gt;a();&lt;br&gt;多次调用的时候 只让它执行一次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;lodash-one-的实现&quot;&gt;&lt;a href=&quot;#lodash-on
    
    </summary>
    
      <category term="前端" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试题" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="https://hyb628.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题：传入任意1-7的数组转为对应星期问题</title>
    <link href="https://hyb628.github.io/2017/06/28/%E4%BC%A0%E5%85%A5%E4%BB%BB%E6%84%8F1-7%E7%9A%84%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E5%AF%B9%E5%BA%94%E6%98%9F%E6%9C%9F%E9%97%AE%E9%A2%98/"/>
    <id>https://hyb628.github.io/2017/06/28/传入任意1-7的数组转为对应星期问题/</id>
    <published>2017-06-28T01:55:08.000Z</published>
    <updated>2017-07-06T02:39:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>已知一个1-7的数组 输出对应的星期<br>如:<br>输入 [1, 2, 3, 5, 6]  —-&gt; 输出 星期1-星期3  星期5  星期6<br>输入 [1, 2, 5, 6]  —-&gt; 输出 星期1-星期2  星期5  星期5<br>输入 [1, 2, 4, 5, 6, 7]  —-&gt; 输出 星期1-星期2  星期5-星期6  星期7</p>
</blockquote>
<script async src="//jsfiddle.net/hyb628/tm4e233f/embed/js,html,result/"></script>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;已知一个1-7的数组 输出对应的星期&lt;br&gt;如:&lt;br&gt;输入 [1, 2, 3, 5, 6]  —-&amp;gt; 输出 星期1-星期3  星期5  星期6&lt;br&gt;输入 [1, 2, 5, 6]  —-&amp;gt; 输出 星期1-星期2  星期5  星期5&lt;
    
    </summary>
    
      <category term="前端" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试题" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="https://hyb628.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题：setTimeout 0 与 Promise的执行时机</title>
    <link href="https://hyb628.github.io/2017/06/28/setTimeout%200%20%E4%B8%8E%20Promise%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/"/>
    <id>https://hyb628.github.io/2017/06/28/setTimeout 0 与 Promise的执行时机/</id>
    <published>2017-06-28T01:55:08.000Z</published>
    <updated>2017-07-06T04:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>题目是这样的：<br>function a() {}<br>a();<br>a();<br>多次调用的时候 只让它执行一次。</p>
</blockquote>
<h6 id="lodash-one-的实现"><a href="#lodash-one-的实现" class="headerlink" title="lodash.one 的实现"></a>lodash.one 的实现</h6><script async src="//jsfiddle.net/hyb628/h41tx68s/embed/js/"></script>

<h5 id="另一种实现"><a href="#另一种实现" class="headerlink" title="另一种实现"></a>另一种实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function once(fn, context) &#123; </div><div class="line">    var result;</div><div class="line"> </div><div class="line">    return function() &#123; </div><div class="line">        if(fn) &#123;</div><div class="line">            result = fn.apply(context || this, arguments);</div><div class="line">            fn = null;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        return result;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// Usage</div><div class="line">var canOnlyFireOnce = once(function() &#123;</div><div class="line">    console.log(&apos;Fired!&apos;);</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">canOnlyFireOnce(); // &quot;Fired!&quot;</div><div class="line">canOnlyFireOnce(); // nothing</div></pre></td></tr></table></figure>
<h5 id="或者是"><a href="#或者是" class="headerlink" title="或者是"></a>或者是</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function test () &#123;console.log(&apos;test&apos;)&#125;</div><div class="line"></div><div class="line">var once = function (fn) &#123;</div><div class="line">  var isFirst = true;</div><div class="line">  return function () &#123;</div><div class="line">    if (isFirst) &#123;</div><div class="line">      isFirst = !isFirst;</div><div class="line">      fn();</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var b = once(test);</div><div class="line">b(); // &apos;test&apos;</div><div class="line">b(); // nothing</div></pre></td></tr></table></figure>
<p>其实实现的原理还是通过闭包的形式 通过一个flag标志来记录是否被调用过， 有的话就标记为true 然后再置为false这样的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;题目是这样的：&lt;br&gt;function a() {}&lt;br&gt;a();&lt;br&gt;a();&lt;br&gt;多次调用的时候 只让它执行一次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;lodash-one-的实现&quot;&gt;&lt;a href=&quot;#lodash-on
    
    </summary>
    
      <category term="前端" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试题" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="https://hyb628.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>supervisor自动监测文件修改</title>
    <link href="https://hyb628.github.io/2017/06/23/supervisor%E7%9B%91%E6%B5%8B%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9/"/>
    <id>https://hyb628.github.io/2017/06/23/supervisor监测文件修改/</id>
    <published>2017-06-23T06:26:24.000Z</published>
    <updated>2017-06-23T11:58:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>在node.js中，有时候项目中修改一个配置文件，需要重新<code>npm start</code> , supervisor插件很好的解决了这一难题。</p>
<h4 id="supervisor安装"><a href="#supervisor安装" class="headerlink" title="supervisor安装"></a>supervisor安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i -g supervisor</div></pre></td></tr></table></figure>
<h4 id="supervisor参数"><a href="#supervisor参数" class="headerlink" title="supervisor参数"></a>supervisor参数</h4><p>监控的文件夹或文件，默认为’.’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-w | --watch &lt;watchItems&gt;</div></pre></td></tr></table></figure>
<p>要忽略监控的文件夹或js文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-i | --ignore &lt;ignoreItems&gt;</div></pre></td></tr></table></figure>
<p>监控文件变化的时间间隔（周期），默认为Node.js内置的时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-p | --poll-interval &lt;milliseconds&gt;</div></pre></td></tr></table></figure></p>
<p>要执行的主应用程序，默认为’node’：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-x | --exec &lt;executable&gt;</div></pre></td></tr></table></figure>
<p>开启debug模式（用–debug flag来启动node）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">--debug</div></pre></td></tr></table></figure></p>
<p>安静模式，不显示DEBUG信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-q |--quiet</div></pre></td></tr></table></figure></p>
<h4 id="package-json中使用"><a href="#package-json中使用" class="headerlink" title="package.json中使用"></a>package.json中使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">    &quot;start&quot;: &quot;supervisor server.js&quot;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在node.js中，有时候项目中修改一个配置文件，需要重新&lt;code&gt;npm start&lt;/code&gt; , supervisor插件很好的解决了这一难题。&lt;/p&gt;
&lt;h4 id=&quot;supervisor安装&quot;&gt;&lt;a href=&quot;#supervisor安装&quot; class=&quot;he
    
    </summary>
    
      <category term="前端" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="webpack" scheme="https://hyb628.github.io/tags/webpack/"/>
    
      <category term="supervisor" scheme="https://hyb628.github.io/tags/supervisor/"/>
    
      <category term="plugin" scheme="https://hyb628.github.io/tags/plugin/"/>
    
  </entry>
  
  <entry>
    <title>setState不及时更新的问题</title>
    <link href="https://hyb628.github.io/2017/06/01/%E4%B8%BA%E5%95%A5%E8%AF%B4setState%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84/"/>
    <id>https://hyb628.github.io/2017/06/01/为啥说setState是异步的/</id>
    <published>2017-06-01T08:46:53.000Z</published>
    <updated>2017-06-02T07:54:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>老早前在做项目的时候，遇到表单设置select下拉，选择完选项 在其他function函数里面需要拿这个选择的数据，通过 <code>this.state.XXX</code> 去获取，总是拿到一个旧的数据，不会及时的更新，在render里面去拿就能拿到新的数据，当时也没好好去深入，现在做个笔记希望能够思路清晰点。</p>
<blockquote>
<p>React官方的文档解释是： <a href="https://facebook.github.io/react/docs/react-component.html#render" target="_blank" rel="external">Link</a><br>大致的意思是  <code>setState()</code>不会立刻改变 <code>this.state</code>,而是创建一个即将处理的state。<code>setState()</code>并不一定是同步的，为了提升性能React会批量(也就是合并多次的setState)执行state和DOM渲染。<br><code>setState()</code>总是会触发一次组件重绘，除非在<code>shouldComponentUpdate()</code>中实现了一些条件渲染逻辑。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var Counter = React.createClass(&#123;</div><div class="line">    getInitialState: function () &#123;</div><div class="line">        return &#123; clickCount: 0 &#125;;</div><div class="line">    &#125;,</div><div class="line">    handleClick: function () &#123;</div><div class="line">    this.setState(&#123;</div><div class="line">        clickCount: this.state.clickCount + 1</div><div class="line">    &#125;);</div><div class="line">    console.log(this.state.clickCount)  // 第一次点击得到 0</div><div class="line">    &#125;,</div><div class="line">    render: function () &#123;</div><div class="line">        return (&lt;h2 onClick=&#123;this.handleClick&#125;&gt;次数为: &#123;this.state.clickCount&#125;&lt;/h2&gt;);  // 第一次点击得到 1</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">ReactDOM.render(</div><div class="line">    &lt;Counter /&gt;,</div><div class="line">    document.getElementById(&apos;message&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>再来试试所谓的合并多次state问题，同样的在这个Demo里我handleClick多次setState 看看是什么情况？ </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var Counter = React.createClass(&#123;</div><div class="line">    getInitialState: function () &#123;</div><div class="line">        return &#123; clickCount: 0 &#125;;</div><div class="line">    &#125;,</div><div class="line">    handleClick: function () &#123;</div><div class="line">    this.setState(&#123;</div><div class="line">        clickCount: this.state.clickCount + 1</div><div class="line">    &#125;);</div><div class="line">    this.setState(&#123;</div><div class="line">        clickCount: this.state.clickCount + 2</div><div class="line">    &#125;);</div><div class="line">    console.log(this.state.clickCount)  // 依次得到 0, 2, 4 ...</div><div class="line">    &#125;,</div><div class="line">    render: function () &#123;</div><div class="line">        return (&lt;h2 onClick=&#123;this.handleClick&#125;&gt;次数为: &#123;this.state.clickCount&#125;&lt;/h2&gt;);   // 依次得到 2, 4, 6 ..</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">ReactDOM.render(</div><div class="line">    &lt;Counter /&gt;,</div><div class="line">    document.getElementById(&apos;message&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>也就是说 在handleClick执行多次<code>setState</code> , react只会执行最后一次的结果。 如果我用计时器<code>setTimeout</code> 看看会有啥新的发现？ </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">handleClick: function () &#123;</div><div class="line">    this.setState(function(state) &#123;</div><div class="line">        return &#123;clickCount: state.clickCount + 1&#125;;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    setTimeout(()=&gt;&#123;</div><div class="line">        console.log(this.state.clickCount)   // 第一次点击 输出 1  render也同样取到 1</div><div class="line">    &#125;,100)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一个方式则是用<code>componentDidUpdate()</code>这个生命周期方法，把确定state更新后要执行的代码放在里面，如下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var Counter = React.createClass(&#123;</div><div class="line">    getInitialState: function () &#123;</div><div class="line">        return &#123; clickCount: 0 &#125;;</div><div class="line">    &#125;,</div><div class="line">    handleClick: function () &#123;</div><div class="line">        this.setState(function(state) &#123;</div><div class="line">            return &#123;clickCount: state.clickCount + 1&#125;;</div><div class="line">        &#125;);</div><div class="line">    &#125;,</div><div class="line">    componentDidUpdate()&#123;</div><div class="line">        console.log(this.state.clickCount)  // 第一次点击 输出 1</div><div class="line">    &#125;,</div><div class="line">    render: function () &#123;</div><div class="line">        console.log(&apos;render&apos;);</div><div class="line">        return (&lt;h2 onClick=&#123;this.handleClick&#125;&gt;次数为: &#123;this.state.clickCount&#125;&lt;/h2&gt;); // render也同样取到 1</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">ReactDOM.render(</div><div class="line">    &lt;Counter /&gt;,</div><div class="line">    document.getElementById(&apos;message&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>react 官方的说明方法提供了callback的回调方式获取最新的state状态 </p>
<blockquote>
<p>setState(object nextState[, function callback])</p>
<ol>
<li>nextState，将要设置的新状态，该状态会和当前的state合并</li>
<li>callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">handleClick: function () &#123;</div><div class="line">    this.setState(&#123;clickCount: this.state.clickCount + 1&#125;, function() &#123;</div><div class="line">        console.log(this.state.clickCount)  // 依次输出 1, 2, 3 ...</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>[参考]<br><a href="http://www.jianshu.com/p/2d50a413e74a" target="_blank" rel="external">为什么setState没有立即执行</a><br><a href="https://segmentfault.com/a/1190000007454080" target="_blank" rel="external">为何说setState方法是异步的？</a><br><a href="https://zhuanlan.zhihu.com/p/20328570" target="_blank" rel="external">解密 setState</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;老早前在做项目的时候，遇到表单设置select下拉，选择完选项 在其他function函数里面需要拿这个选择的数据，通过 &lt;code&gt;this.state.XXX&lt;/code&gt; 去获取，总是拿到一个旧的数据，不会及时的更新，在render里面去拿就能拿到新的数据，当时也没好
    
    </summary>
    
      <category term="前端" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://hyb628.github.io/tags/JavaScript/"/>
    
      <category term="React" scheme="https://hyb628.github.io/tags/React/"/>
    
      <category term="setState" scheme="https://hyb628.github.io/tags/setState/"/>
    
  </entry>
  
  <entry>
    <title>JS 反转二叉树</title>
    <link href="https://hyb628.github.io/2017/06/01/JS%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://hyb628.github.io/2017/06/01/JS反转二叉树/</id>
    <published>2017-06-01T08:46:53.000Z</published>
    <updated>2017-06-02T05:06:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>面试的时候，问了一个反转二叉树的实现，做个笔记。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Invert a binary tree.</div><div class="line"></div><div class="line">     4</div><div class="line">   /   \</div><div class="line">  2     7</div><div class="line"> / \   / \</div><div class="line">1   3 6   9</div><div class="line"></div><div class="line">to</div><div class="line"></div><div class="line">     4</div><div class="line">   /   \</div><div class="line">  7     2</div><div class="line"> / \   / \</div><div class="line">9   6 3   1</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var invertTree = function(root) &#123;</div><div class="line">    if(root == null) &#123; // 如果不存在，则返回[]</div><div class="line">        return root;</div><div class="line">    &#125; else &#123; // 交换左右结点</div><div class="line">        var temp = root.left;</div><div class="line">        root.left  = root.right;</div><div class="line">        root.right = temp;</div><div class="line">    &#125;</div><div class="line">    invertTree(root.left); // 转换左子树</div><div class="line">    invertTree(root.right); // 转换右子树</div><div class="line">    return root;//返回最后结果</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试的时候，问了一个反转二叉树的实现，做个笔记。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line
    
    </summary>
    
      <category term="前端" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://hyb628.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6的Array.from、Set数组去重</title>
    <link href="https://hyb628.github.io/2016/09/14/ES6%E7%9A%84Array.from%E3%80%81Set%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <id>https://hyb628.github.io/2016/09/14/ES6的Array.from、Set数组去重/</id>
    <published>2016-09-14T06:26:24.000Z</published>
    <updated>2017-04-29T04:03:15.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h5><p>ES6中新增了Set数据结构，类似于数组，但是 它的成员都是唯一的 ，其构造函数可以接受一个数组作为参数，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(array);</div><div class="line"><span class="built_in">console</span>.log(set);</div><div class="line"><span class="comment">// =&gt; Set &#123;1, 2, 3, 4, 5&#125;</span></div></pre></td></tr></table></figure>
<h5 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h5><p>ES6中Array新增了一个静态方法<code>Array.from</code>，可以把类似数组的对象转换为数组，如通过<code>querySelectAll</code>方法得到HTML DOM Node List，以及ES6中新增的<code>Set</code>和<code>Map</code>等可遍历对象，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</div><div class="line">set.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">3</span>);</div><div class="line"><span class="keyword">let</span> array = <span class="built_in">Array</span>.from(set);</div><div class="line"><span class="built_in">console</span>.log(array); <span class="comment">//  [1, 2, 3]</span></div></pre></td></tr></table></figure>
<p>于是，现在我们可以用一行代码实现数组去重了：于是，现在我们可以用一行代码实现数组去重了:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> array = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]));</div><div class="line"><span class="built_in">console</span>.log(array); <span class="comment">//[1, 2, 3, 4]</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;Set数据结构&quot;&gt;&lt;a href=&quot;#Set数据结构&quot; class=&quot;headerlink&quot; title=&quot;Set数据结构&quot;&gt;&lt;/a&gt;Set数据结构&lt;/h5&gt;&lt;p&gt;ES6中新增了Set数据结构，类似于数组，但是 它的成员都是唯一的 ，其构造函数可以接受一个数组作为
    
    </summary>
    
      <category term="前端" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="https://hyb628.github.io/tags/ES6/"/>
    
      <category term="数组去重" scheme="https://hyb628.github.io/tags/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    
  </entry>
  
  <entry>
    <title>阶段性技术啰嗦（二）</title>
    <link href="https://hyb628.github.io/2016/09/03/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%8A%80%E6%9C%AF%E5%95%B0%E5%97%A62/"/>
    <id>https://hyb628.github.io/2016/09/03/阶段性技术啰嗦2/</id>
    <published>2016-09-03T06:26:24.000Z</published>
    <updated>2017-04-29T04:16:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>记得上次<a href="/2016/05/20/阶段性技术啰嗦1/">阶段性啰嗦</a>是在5月份，转眼间，就到九月了，时间过的好快，又过得好漫长，两点一线的生活，充实的生活，也懒到了一定的境界，甚是乏累。今天公司网络升级改造，所以早早就回来，就想起写点啥，虽然经验少，肚子里没墨水也想挣扎一番。Let me see ! </p>
</blockquote>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=436514312&auto=1&height=66"></iframe>

<p><strong>说下最近都在忙啥吧：</strong><br>七月份开始一直到现在一直在弄Approve项目，推迟了上线时间，因为尝试用了React新框架，遇到的问题也挺多了，禅道的Bug可真不是一般的多的。所以，一直解决Bug中。负责这个项目的我们三个人就这么Coding。说到底，项目逻辑的复杂度不是一般的复杂。刚毕业那会工作，主要前端开发的一般偏向UI方面，所以，交互，数据方面一般处理的比较少甚至基本都是交于后端处理，这方面比较薄弱，经过以前的面试洗礼，有个面试官说，我们只要做JS交互方面的，才下定决心一定要坚持在这方向努力学习才行。不过，也很感叹，一开始以为切切图的码畜，原来常挂嘴里的切图，自从遇到了公司了一位设计转UI切图的资深女同事才发现，原来切图人家真的到了一定的境界，让我好生佩服。</p>
<p><strong>说说最近的一些问题：</strong><br>刚开始我们老大说项目重构，要用React，所以，很正常，很多人肯定没接触了，都要从0开始，毕竟，在Ag横行的年代，也是还是有一些牛逼的技术栈并行。记得6月份就说要用了，然后自己也看了FB官网的API，东西也不多，但是，React 只是负责V层面上的东西，伴随它有用的东西就一个<code>state</code>和<code>props</code>, 以及一些<code>生命周期</code>，在<code>React中，数据的流向是单向的</code>，基于<code>react + redux</code>的模式开发配合着ES6（ES6很多东西写着确实不错，就那么些，Babel就帮你搞定了，加上Webpack可以把你代码转为兼容低版本的ES3或者是ES5之类的代码）就这么孕育而生。</p>
<h5 id="Redux-官网"><a href="#Redux-官网" class="headerlink" title="Redux 官网"></a>Redux <a href="http://redux.js.org/" target="_blank" rel="external">官网</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. store 是应用的状态管理中心，保存着是应用的状态（state），当收到状态的更新时，会触发视觉组件进行更新。</div><div class="line">2. container 是视觉组件的容器，负责把传入的状态变量渲染成视觉组件，在浏览器显示出来。</div><div class="line">3. reducer 是动作(action)的处理中心， 负责处理各种动作并产生新的状态（state），返回给store。</div></pre></td></tr></table></figure>
<h5 id="nvm-Github"><a href="#nvm-Github" class="headerlink" title="nvm Github"></a>nvm <a href="https://github.com/creationix/nvm" target="_blank" rel="external">Github</a></h5><p>我Mac是直接用了nvm进行node版本的控制，切换node版本的时候 是直接 <code>nvm use 6.2.1</code>  或者是 <code>nvm use 4.4.5</code> 之类的不同版本切换，如果需要用到的情况下。不过也有其他东西类似的版本控制。</p>
<h5 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h5><p>历时将近6年的时间来制定的新 ECMAScript 标准 ECMAScript 6（亦称 ECMAScript Harmony，简称 ES6）终于在 2015 年 6 月正式发布。自从上一个标准版本 ES5 在 2009 年发布以后，ES6 就一直以新语法、新特性的优越性吸引著众多 JavaScript 开发者，驱使他们积极尝鲜。</p>
<p>阮一峰的<a href="http://es6.ruanyifeng.com/#docs/intro" target="_blank" rel="external">《ECMAScript 6 入门》</a><br>InfoQ上的 <a href="http://www.infoq.com/cn/ES6-In-Depth/articles/" target="_blank" rel="external">《深入浅出ES6》</a> </p>
<p>一般都是都是看这两个 比较全， 不过一般用到才去看下或者查下，一般常用的就是箭头函数，或者是解构或者是新增加的一些方法，比较方便，比如<code>Object.assign()</code> 项目里也用的比较多，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.assign(target, ...sources)</div><div class="line">Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。</div></pre></td></tr></table></figure>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="external">直接戳MDN</a></p>
<p>类似的字符串模板也不过 比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const names = `一喵呜`;</div><div class="line">console.log(`$&#123;names&#125; binjs.com`);</div><div class="line"></div><div class="line">result: 一喵呜 binjs.com</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Spread： </div><div class="line">export function getSelCCuser(options) &#123;</div><div class="line">    const &#123; approveId, ...others  &#125; = options;</div><div class="line">    return httpUtil.post(`/api/approve/w1/approves/$&#123;approveId&#125;/cc`,  &#123;...others&#125; );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const &#123; detail, name &#125; = this,props</div><div class="line">const &#123; names &#125; = this.state</div></pre></td></tr></table></figure>
<p>还有比如，项目遇到一个前端模糊搜索匹配问题，想到正则比较麻烦，还好，想到ES6有<code>includes()</code> 这个东西，一切就好办了。</p>
<p>之类的 等等，还是不错的。</p>
<h5 id="Ant-Design-官网"><a href="#Ant-Design-官网" class="headerlink" title="Ant-Design 官网"></a>Ant-Design <a href="http://ant.design/" target="_blank" rel="external">官网</a></h5><p>项目UI基于蚂蚁金服的ant进行组件开发，项目里需要用到一个抽屉组件，一开始，真不知道怎么搞，不过，最后不知道怎么纠结，最后，把抽屉小组件写了整合进ant项目里，发布到npm，供以后公司项目其他项目模块重构可以服用，不过蚂蚁金服确实很赞，但是还是也还是遇到很多问题，真的操碎心。</p>
<p>这几天，发现基于<code>React Nactive</code>的<code>mobile ant</code>组件出来了，虽然没用过不过还是很好奇的。<a href="http://mobile.ant.design/" target="_blank" rel="external">Mobile官网</a>  </p>
<p>之前Leader说一人写几个组件，然后因为组件要整合的太多，因为React都是很多一个个小组件，UI样式也没，最后就直接用蚂蚁金服这个来复用开发，还有类似的很多 比如： <a href="http://amazeui.org/react/" target="_blank" rel="external">Amaze-UI</a> ， <a href="http://www.material-ui.com/#/" target="_blank" rel="external">Material-UI</a>，但后面这两个确实不行。哈。</p>
<p>React 组件间的通信，纯粹自己理解就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1. 父级 --&gt; 子级 ： props</div><div class="line">2. 子级 --&gt; 父级： callback</div></pre></td></tr></table></figure></p>
<h5 id="lodash-官网"><a href="#lodash-官网" class="headerlink" title="lodash 官网"></a>lodash <a href="https://lodash.com/docs/4.15.0/" target="_blank" rel="external">官网</a></h5><p>Approve项目还引入了一个工具库，算是对JS的一个扩充吧。有些API用着还是不错的。</p>
<h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p>Promise这个水好深，反正现在就是我只知道的理解就是异步的处理 ，<code>then</code>的类似回调。不过看了这篇文章还是太难过了。比较稚嫩 ， 抽根烟先去睡觉。后面好好学习。 再做补充。</p>
<p>保存个书签：<br><a href="http://liubin.org/promises-book" target="_blank" rel="external">Promise迷你书（中文版）</a><br><a href="http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/" target="_blank" rel="external">[翻译] We have a problem with promises</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记得上次&lt;a href=&quot;/2016/05/20/阶段性技术啰嗦1/&quot;&gt;阶段性啰嗦&lt;/a&gt;是在5月份，转眼间，就到九月了，时间过的好快，又过得好漫长，两点一线的生活，充实的生活，也懒到了一定的境界，甚是乏累。今天公司网络升级改造，所以早早就回来，就
    
    </summary>
    
      <category term="前端" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="https://hyb628.github.io/tags/ES6/"/>
    
      <category term="JSX" scheme="https://hyb628.github.io/tags/JSX/"/>
    
      <category term="React" scheme="https://hyb628.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>求负数的二进制</title>
    <link href="https://hyb628.github.io/2016/09/03/%E8%B4%9F%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    <id>https://hyb628.github.io/2016/09/03/负数的二进制/</id>
    <published>2016-09-03T06:26:24.000Z</published>
    <updated>2017-06-02T17:03:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>[转]</p>
<p>负数用二进制表达。比如，假设有一 int 类型的数，值为5，那么，我们知道它在计算机中表示为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">00000000 00000000 00000000 00000101</div></pre></td></tr></table></figure></p>
<p>5转换成二制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0。<br>现在想知道，-5在计算机中如何表示？</p>
<blockquote>
<p>在计算机中，负数以其正值的补码形式表达。</p>
</blockquote>
<p>什么叫补码呢？这得从原码，反码说起。</p>
<blockquote>
<p>原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。</p>
</blockquote>
<p>比如 <code>00000000 00000000 00000000 00000101</code> 是 5的 原码。<br>反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。<br>取反操作指：原为1，得0；原为0，得1。（1变0; 0变1）<br>比如：将<code>00000000 00000000 00000000 00000101</code>每一位取反，得<code>11111111 11111111 11111111 11111010</code>。</p>
<p>称：<code>11111111 11111111 11111111 11111010</code> 是 <code>00000000 00000000 00000000 00000101</code> 的反码。</p>
<p>反码是相互的，所以也可称：</p>
<p><code>11111111 11111111 11111111 11111010</code> 和 <code>00000000 00000000 00000000 00000101</code> 互为反码。
　</p>
<blockquote>
<p>补码：反码加1称为补码。</p>
</blockquote>
<p>也就是说，要得到一个数的补码，先得到反码，然后将反码加上1，所得数称为补码。<br>比如：<code>00000000 00000000 00000000 00000101</code> 的反码是：<code>11111111 11111111 11111111 11111010</code>。<br>那么，补码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011</div></pre></td></tr></table></figure>
<p>所以，-5 在计算机中表达为：<code>11111111 11111111 11111111 11111011</code>。转换为十六进制：<code>0xFFFFFFFB</code>。<br>再举一例，我们来看整数-1在计算机中如何表示。<br>假设这也是一个int类型，那么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1、先取1的原码： 00000000 00000000 00000000 00000001</div><div class="line">2、得反码：     11111111 11111111 11111111 11111110</div><div class="line">3、得补码：     11111111 11111111 11111111 11111111</div></pre></td></tr></table></figure>
<p>可见，－1在计算机里用二进制表达就是全1。16进制为：0xFFFFFF</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[转]&lt;/p&gt;
&lt;p&gt;负数用二进制表达。比如，假设有一 int 类型的数，值为5，那么，我们知道它在计算机中表示为：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div cla
    
    </summary>
    
      <category term="计算机基础" scheme="https://hyb628.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="二进制" scheme="https://hyb628.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>随笔 2016-08-6</title>
    <link href="https://hyb628.github.io/2016/08/06/20160806%E9%9A%8F%E7%AC%94/"/>
    <id>https://hyb628.github.io/2016/08/06/20160806随笔/</id>
    <published>2016-08-06T08:36:17.000Z</published>
    <updated>2017-04-29T08:48:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>深夜，又是一个周末，难得这个周末啥都断想，啥都不管，就这么放空。</p>
<p><img src="/images/20160806/2016-8-6.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深夜，又是一个周末，难得这个周末啥都断想，啥都不管，就这么放空。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/20160806/2016-8-6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="生活" scheme="https://hyb628.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="https://hyb628.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="生活" scheme="https://hyb628.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>SASS用法小记</title>
    <link href="https://hyb628.github.io/2016/06/18/SASS%E7%94%A8%E6%B3%95%E5%B0%8F%E8%AE%B0/"/>
    <id>https://hyb628.github.io/2016/06/18/SASS用法小记/</id>
    <published>2016-06-18T08:46:53.000Z</published>
    <updated>2017-04-29T08:55:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前项目用LESS，现在新项目打算用SASS，所以做个主要常用知识点小记。</p>
<h4 id="在线编译地址"><a href="#在线编译地址" class="headerlink" title="在线编译地址"></a><a href="http://www.sassmeister.com/" target="_blank" rel="external">在线编译地址</a></h4><h4 id="import-引入"><a href="#import-引入" class="headerlink" title="@import 引入"></a>@import 引入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">　@import &quot;../binjs.scss&quot;;  // 引入文件</div><div class="line">　@import &quot;../huangyb.css&quot;;</div></pre></td></tr></table></figure>
<h4 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="@mixin 混入"></a>@mixin 混入</h4><blockquote>
<p>注意：LESS的变量用<code>@</code> , SASS是 <code>$</code> </p>
</blockquote>
<ul>
<li>带参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@mixin borderSet($dott: solid, $color: #fcf) &#123;</div><div class="line">  border: 8px $dott $color;</div><div class="line">&#125;</div><div class="line">div &#123;</div><div class="line">    opacity: 0;</div><div class="line">    @include borderSet(dotted, #fa0); //带参数传入</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>不带参数 显示默认值 不定义参数值 就显示默认值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@mixin borderSet($dott: solid, $color: #fcf) &#123;</div><div class="line">  border: 8px $dott $color;</div><div class="line">&#125;</div><div class="line">div &#123;</div><div class="line">    opacity: 0;</div><div class="line">    @include borderSet; //不带参数传入 可括号 可不括号</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><blockquote>
<p>LESS也是一样的嵌套规则， <code>&amp;</code> 符号都相同</p>
</blockquote>
<ul>
<li><p>使用&amp;引用父元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">div &#123;</div><div class="line">    opacity: 0;</div><div class="line">    @include borderSet(); //不带参数传入 可括号 可不括号</div><div class="line">    &amp;:after  &#123;</div><div class="line">      color:#ccc;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>属性的嵌套</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> p &#123;</div><div class="line">  border: &#123;</div><div class="line">    color:red;</div><div class="line">    width:12px;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="变量用-包裹"><a href="#变量用-包裹" class="headerlink" title="变量用 #{} 包裹"></a>变量用 <code>#{}</code> 包裹</h4><p>如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。一般来说，我们设置的变量都是用于属性值的，而如果用在属性或者选择器上，就得以#{}包裹起来了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$className:huangyb;</div><div class="line">.#&#123;$className&#125; &#123;</div><div class="line">  width: 12px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 解析成</div><div class="line">.huangyb &#123;</div><div class="line">  width: 12px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$side : left;</div><div class="line">.#&#123;$side&#125; &#123;</div><div class="line">　　border-#&#123;$side&#125;-radius: 5px;</div><div class="line">&#125;</div><div class="line">// 解析成</div><div class="line">.left &#123;</div><div class="line">  　　border-left-radius: 5px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="default-的使用"><a href="#default-的使用" class="headerlink" title="!default 的使用"></a>!default 的使用</h4><p>正常情况下 声明两个变量 会出现后面覆盖前面的变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$color:red;</div><div class="line">$color:blue;</div><div class="line">p&#123;</div><div class="line">    color:$color; //blue</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若声明了 <code>!default</code> 会就不能出现覆盖的现象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$color:red;</div><div class="line">$color:blue !default;</div><div class="line">p&#123;</div><div class="line">    color:$color; //red</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="多个变量的声明"><a href="#多个变量的声明" class="headerlink" title="多个变量的声明"></a>多个变量的声明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$linkColor: red blue;</div><div class="line"></div><div class="line">a&#123;</div><div class="line">    color:nth($linkColor,1);</div><div class="line">    &amp;:hover&#123;</div><div class="line">        color:nth($linkColor,2);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 解析后</div><div class="line">a &#123;</div><div class="line">  color: red;</div><div class="line">&#125;</div><div class="line">a:hover &#123;</div><div class="line">  color: blue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="extend-继承"><a href="#extend-继承" class="headerlink" title="@extend 继承"></a>@extend 继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">div &#123; </div><div class="line">  color:#fcf; </div><div class="line">  </div><div class="line">&#125;</div><div class="line">p &#123; </div><div class="line">  @extend div; </div><div class="line">  width:10px; </div><div class="line">&#125;</div><div class="line">span &#123;</div><div class="line">  @extend p;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 解析后</div><div class="line">div, p, span &#123;</div><div class="line">  color: #fcf;</div><div class="line">&#125;</div><div class="line"></div><div class="line">p, span &#123;</div><div class="line">  width: 10px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="function"><a href="#function" class="headerlink" title="function"></a>function</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@function binjs($value) &#123;</div><div class="line">  @return #&#123;$value&#125;px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">div &#123;</div><div class="line">  width: binjs(30);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//解析后</div><div class="line">div &#123;</div><div class="line">  width: 30px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="if-else-条件判断"><a href="#if-else-条件判断" class="headerlink" title="@if @else 条件判断"></a>@if @else 条件判断</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$width:12px;</div><div class="line">div &#123;</div><div class="line">  @if ($width&gt;10) &#123;</div><div class="line">     color:#fcf;</div><div class="line">  &#125; @else &#123;</div><div class="line">    color:#fa0;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前项目用LESS，现在新项目打算用SASS，所以做个主要常用知识点小记。&lt;/p&gt;
&lt;h4 id=&quot;在线编译地址&quot;&gt;&lt;a href=&quot;#在线编译地址&quot; class=&quot;headerlink&quot; title=&quot;在线编译地址&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://www.sas
    
    </summary>
    
      <category term="前端" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="https://hyb628.github.io/tags/CSS/"/>
    
      <category term="SASS" scheme="https://hyb628.github.io/tags/SASS/"/>
    
  </entry>
  
  <entry>
    <title>ES6数组的扩展</title>
    <link href="https://hyb628.github.io/2016/06/13/ES6%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://hyb628.github.io/2016/06/13/ES6数组的扩展/</id>
    <published>2016-06-13T08:46:53.000Z</published>
    <updated>2017-04-29T09:36:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天培训了,只能自己看这些东西啦。一天时间又过去了。现在文章，或者我的印象笔记都是采用Markdown 来写了， 是不是看起来比较整洁了。有点想改用Hexo, 看着很不错，markdown 也写得比较有意思 貌似。 一直想弄 ，但是又怕麻烦。</p>
<h5 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let arrayLike = &#123;</div><div class="line">    &apos;0&apos;: &apos;a&apos;,</div><div class="line">    &apos;1&apos;: &apos;b&apos;,</div><div class="line">    &apos;2&apos;: &apos;c&apos;,</div><div class="line">    length: 3</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// ES5的写法</div><div class="line">var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</div><div class="line">等同于：</div><div class="line">var arr1 = Array.prototype.slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</div><div class="line"></div><div class="line">// ES6的写法</div><div class="line">let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</div></pre></td></tr></table></figure>
<p><a href="http://www.binjs.com/archives/1560" target="_blank" rel="external">查看之前文章Array.prototype.slice.call介绍</a></p>
<p>不过，对象数组的写法需要严格按照规范写，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;0:&apos;hello&apos;,1:&apos;world&apos;,length:4&#125;;</div><div class="line"></div><div class="line">Array.prototype.slice.call(foo);  // [&quot;hello&quot;, &quot;world&quot;, undefined × 2]</div><div class="line">Array.from(arrayLike); // [&quot;hello&quot;, &quot;world&quot;, undefined, undefined]</div></pre></td></tr></table></figure></p>
<p><code>Array.from()</code>   的第一个参数决定第二个参数的执行次数， </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Array.from(&#123; length: 3 &#125;); // [undefined, undefined, undefinded]</div><div class="line">Array.from(&#123;length:3&#125;,() =&gt;&apos;binjs&apos;); // [&apos;binjs&apos;, &apos;binjs&apos;, &apos;binjs&apos;]</div></pre></td></tr></table></figure>
<p><code>Array.from()</code>   还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Array.from(arrayLike, x =&gt; x * x);</div><div class="line">// 等同于</div><div class="line">Array.from(arrayLike).map(x =&gt; x * x);</div><div class="line"></div><div class="line">Array.from([1, 2, 3], (x) =&gt; x * x)</div><div class="line">// [1, 4, 9]</div></pre></td></tr></table></figure>
<p>只要是部署了<code>Iterator</code>接口的数据结构，<code>Array.from</code>都能将其转为数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Array.from(&apos;hello&apos;); // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]</div><div class="line"></div><div class="line">let namesSet = new Set([&apos;a&apos;, &apos;b&apos;]);</div><div class="line">Array.from(namesSet); // [&apos;a&apos;, &apos;b&apos;]</div></pre></td></tr></table></figure></p>
<h5 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h5><p>方法用于将一组值，转换为数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Array.of() // []</div><div class="line">Array.of(undefined) // [undefined]</div><div class="line">Array.of(1) // [1]</div><div class="line">Array.of(1, 2) // [1, 2]</div></pre></td></tr></table></figure>
<h5 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h5><p>与字符串的includes方法类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[1,2,3].includes(1); // true</div></pre></td></tr></table></figure></p>
<h5 id="ind-和-findIndex"><a href="#ind-和-findIndex" class="headerlink" title="ind() 和 findIndex()"></a>ind() 和 findIndex()</h5><p><code>find()</code> 返回数组中满足测试条件的一个元素，如果没有满足条件的元素，则返回 <code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[1, 4, -5, 10].find((n) =&gt; n &lt; 0)</div></pre></td></tr></table></figure>
<p> <code>find</code>方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[1, 3, 5].find(function(value, index, arr) &#123;</div><div class="line">  console.log(value);</div><div class="line">  console.log(index);</div><div class="line">  console.log(arr); </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><code>findIndex()</code>  用来查找指定的索引，如果找不到指定的元素, 则返回 <code>-1</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;</div><div class="line">  return value &gt; 9;</div><div class="line">&#125;) // 2</div></pre></td></tr></table></figure>
<h5 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h5><p><code>fill()</code>  用来进行数组的填充 ，第二和第三个参数表示开始和结束位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 0, 1) //[7, &quot;b&quot;, &quot;c&quot;]</div><div class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 0, 2) // [7, 7, &quot;c&quot;]</div></pre></td></tr></table></figure>
<p><code>fill()</code>  可以用来初始化一个数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)</div><div class="line">// [7, 7, 7]</div><div class="line"></div><div class="line">new Array(3).fill(7)</div><div class="line">// [7, 7, 7]</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天培训了,只能自己看这些东西啦。一天时间又过去了。现在文章，或者我的印象笔记都是采用Markdown 来写了， 是不是看起来比较整洁了。有点想改用Hexo, 看着很不错，markdown 也写得比较有意思 貌似。 一直想弄 ，但是又怕麻烦。&lt;/p&gt;
&lt;h5 id=&quot;Arr
    
    </summary>
    
      <category term="前端" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="https://hyb628.github.io/tags/ES6/"/>
    
      <category term="JavaScript" scheme="https://hyb628.github.io/tags/JavaScript/"/>
    
      <category term="数组" scheme="https://hyb628.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>ES6数值的扩展</title>
    <link href="https://hyb628.github.io/2016/06/12/ES6%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://hyb628.github.io/2016/06/12/ES6数值的扩展/</id>
    <published>2016-06-12T08:46:53.000Z</published>
    <updated>2017-04-29T09:45:43.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h5><p>ES6提供了二进制和八进制数值的新的写法，分别用前缀<code>0b（或0B）</code>和<code>0o（或0O）</code>表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0b111110111 === 503 // true</div><div class="line">0o767 === 503 // true</div></pre></td></tr></table></figure>
<p>转为十进制的方法 使用<code>Number</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Number(&apos;0b111&apos;)  // 7</div><div class="line">Number(&apos;0o10&apos;)   // 8</div></pre></td></tr></table></figure>
<h6 id="Number-isFinite"><a href="#Number-isFinite" class="headerlink" title="Number.isFinite()"></a>Number.isFinite()</h6><p>用来检测传入的参数是否是一个有穷数。和全局的 <code>isFinite()</code> 函数相比，这个方法不会强制将一个非数字的参数转换成数字，这就意味着，只有真正的数字才有可能返回 true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Number.isFinite(15); // true</div><div class="line">Number.isFinite(0.8); // true</div><div class="line">Number.isFinite(NaN); // false</div><div class="line">Number.isFinite(Infinity);  // false</div><div class="line">Number.isFinite(-Infinity); // false</div><div class="line">Number.isFinite(&apos;foo&apos;);     // false</div><div class="line">Number.isFinite(&apos;15&apos;);      // false</div><div class="line">Number.isFinite(true);      // false</div><div class="line">Number.isFinite(0);         // true</div><div class="line">Number.isFinite(2e64);      // true</div><div class="line">Number.isFinite(&apos;0&apos;);       // false, 全局函数 isFinite(&apos;0&apos;) 会返回 true</div></pre></td></tr></table></figure>
<h6 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN()"></a>Number.isNaN()</h6><p>用来检查一个值是否为<code>NaN</code>。</p>
<p>这两个新方法只对数值有效，非数值一律返回false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">isFinite(25) // true</div><div class="line">isFinite(&quot;25&quot;) // true</div><div class="line">Number.isFinite(25) // true</div><div class="line">Number.isFinite(&quot;25&quot;) // false</div><div class="line"></div><div class="line">isNaN(NaN) // true</div><div class="line">isNaN(&quot;NaN&quot;) // true</div><div class="line">Number.isNaN(NaN) // true</div><div class="line">Number.isNaN(&quot;NaN&quot;) // false</div></pre></td></tr></table></figure>
<h6 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(), Number.parseFloat()"></a>Number.parseInt(), Number.parseFloat()</h6><p>ES6 将全局的parseInt 和 parseFloat移植到Number对象上</p>
<h6 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h6><p>用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3 与 3.0 || 3.00 被视为同一个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Number.isInteger(25) // true</div><div class="line">Number.isInteger(25.0) // true</div><div class="line">Number.isInteger(25.1) // false</div><div class="line">Number.isInteger(&quot;15&quot;) // false</div><div class="line">Number.isInteger(true) // false</div></pre></td></tr></table></figure>
<h6 id="Number-EPSILON-常量"><a href="#Number-EPSILON-常量" class="headerlink" title="Number.EPSILON 常量"></a>Number.EPSILON 常量</h6><p>ES6在Number对象上面，新增一个极小的常量<code>Number.EPSILON</code>。</p>
<p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">0.1 + 0.2</div><div class="line">// 0.30000000000000004</div><div class="line"></div><div class="line">0.1 + 0.2 - 0.3</div><div class="line">// 5.551115123125783e-17</div><div class="line"></div><div class="line">5.551115123125783e-17.toFixed(20)</div><div class="line">// &apos;0.00000000000000005551&apos;</div></pre></td></tr></table></figure>
<p>但是如果这个误差能够小于<code>Number.EPSILON</code>，我们就可以认为得到了正确结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">5.551115123125783e-17 &lt; Number.EPSILON  // true</div></pre></td></tr></table></figure>
<h5 id="Math对象的扩展"><a href="#Math对象的扩展" class="headerlink" title="Math对象的扩展"></a>Math对象的扩展</h5><h6 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h6><p>用于去除一个数的小数部分，返回整数部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Math.trunc(4.1) // 4</div><div class="line">Math.trunc(4.9) // 4</div><div class="line">Math.trunc(-4.1) // -4</div><div class="line">Math.trunc(-4.9) // -4</div><div class="line">Math.trunc(-0.1234) // -0</div><div class="line">Math.trunc(&apos;123.456&apos;) // 123</div></pre></td></tr></table></figure>
<p>对于空值和无法截取整数的值，返回<code>NaN</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Math.trunc(NaN);      // NaN</div><div class="line">Math.trunc(&apos;foo&apos;);    // NaN</div><div class="line">Math.trunc();         // NaN</div><div class="line">Math.trunc(&apos;123a.456&apos;) // NaN</div></pre></td></tr></table></figure>
<h6 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h6><p>用来判断一个数到底是正数、负数、还是零。</p>
<blockquote>
<p>参数为正数，返回+1；<br>参数为负数，返回-1；<br>参数为0，返回0；<br>参数为-0，返回-0;<br>其他值，返回NaN。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Math.sign(-5)     // -1</div><div class="line">Math.sign(5)      // +1</div><div class="line">Math.sign(0)      // +0</div><div class="line">Math.sign(-0)     // -0</div><div class="line">Math.sign(NaN)    // NaN</div><div class="line">Math.sign(&apos;foo&apos;); // NaN</div><div class="line">Math.sign();      // NaN</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;数值的扩展&quot;&gt;&lt;a href=&quot;#数值的扩展&quot; class=&quot;headerlink&quot; title=&quot;数值的扩展&quot;&gt;&lt;/a&gt;数值的扩展&lt;/h5&gt;&lt;p&gt;ES6提供了二进制和八进制数值的新的写法，分别用前缀&lt;code&gt;0b（或0B）&lt;/code&gt;和&lt;code&gt;0o（或0
    
    </summary>
    
      <category term="前端" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="https://hyb628.github.io/tags/ES6/"/>
    
      <category term="JavaScript" scheme="https://hyb628.github.io/tags/JavaScript/"/>
    
      <category term="数值" scheme="https://hyb628.github.io/tags/%E6%95%B0%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>ES6解构赋值</title>
    <link href="https://hyb628.github.io/2016/06/11/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>https://hyb628.github.io/2016/06/11/ES6解构赋值/</id>
    <published>2016-06-11T08:46:53.000Z</published>
    <updated>2017-04-29T10:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="配置文件-babelrc"><a href="#配置文件-babelrc" class="headerlink" title="配置文件.babelrc"></a>配置文件.babelrc</h5><p>Babel的配置文件是<code>.babelrc</code>，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。</p>
<h5 id="ES草案阶段"><a href="#ES草案阶段" class="headerlink" title="ES草案阶段"></a>ES草案阶段</h5><ul>
<li>Stage 0 - Strawman（展示阶段）</li>
<li>Stage 1 - Proposal（征求意见阶段）</li>
<li>Stage 2 - Draft（草案阶段）</li>
<li>Stage 3 - Candidate（候选人阶段）</li>
<li>Stage 4 - Finished（定案阶段）</li>
</ul>
<h5 id="let和const-命令"><a href="#let和const-命令" class="headerlink" title="let和const 命令"></a>let和const 命令</h5><p>let不像var那样会发生“变量提升”现象（就是var 定义了 然后输出undefined，let 直接报错 ）。所以，变量一定要在声明后使用，否则报错。</p>
<h6 id="ES6的块级作用域"><a href="#ES6的块级作用域" class="headerlink" title="ES6的块级作用域"></a>ES6的块级作用域</h6><p>let实际上为JavaScript新增了块级作用域。</p>
<p>块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// IIFE写法</div><div class="line">(function () &#123;</div><div class="line">  var tmp = ...;</div><div class="line">  ...</div><div class="line">&#125;());</div><div class="line"></div><div class="line">// 块级作用域写法</div><div class="line">&#123;</div><div class="line">  let tmp = ...;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面的代码如果使用var  输出的是 10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = [];</div><div class="line">for (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">  a[i] = function () &#123;</div><div class="line">    console.log(i);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">a[6](); // 10</div></pre></td></tr></table></figure></p>
<p>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是6。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = [];</div><div class="line">for (let i = 0; i &lt; 10; i++) &#123;</div><div class="line">a[i] = function () &#123;</div><div class="line">    console.log(i);</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">a[6](); // 6</div></pre></td></tr></table></figure>
<h6 id="不存在变量提"><a href="#不存在变量提" class="headerlink" title="不存在变量提"></a>不存在变量提</h6><p><code>let</code>不像<code>var</code>那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。</p>
<h6 id="变量不允许重复声明"><a href="#变量不允许重复声明" class="headerlink" title="变量不允许重复声明"></a>变量不允许重复声明</h6><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>
<h5 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h5><h6 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var [a, b, c] = [1, 2, 3];</div></pre></td></tr></table></figure>
<h6 id="Set-赋值"><a href="#Set-赋值" class="headerlink" title="Set 赋值"></a>Set 赋值</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let [x, y, z] = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);</div></pre></td></tr></table></figure>
<h6 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h6><p>如果一个数组成员不严格等于undefined，默认值是不会生效的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined];</div><div class="line">console.log(x,y)</div></pre></td></tr></table></figure></p>
<p>如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var [x = 1] = [undefined];</div><div class="line">x // 1</div><div class="line"></div><div class="line">var [x = 1] = [null];</div><div class="line">x // null</div></pre></td></tr></table></figure></p>
<p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let [x = 1, y = x] = [];     // x=1; y=1</div><div class="line">let [x = 1, y = x] = [2];    // x=2; y=2</div><div class="line">let [x = 1, y = x] = [1, 2]; // x=1; y=2</div><div class="line">let [x = y, y = 1] = [];     // ReferenceError</div></pre></td></tr></table></figure>
<h6 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var &#123; foo: foo, bar: bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</div></pre></td></tr></table></figure>
<p>对象的解构也可以指定默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var &#123;x = 3&#125; = &#123;&#125;;</div><div class="line">x // 3</div><div class="line"></div><div class="line">var &#123;x, y = 5&#125; = &#123;x: 1&#125;;</div><div class="line">x // 1</div><div class="line">y // 5</div><div class="line"></div><div class="line">var &#123; message: msg = &quot;Something went wrong&quot; &#125; = &#123;&#125;;</div><div class="line">msg // &quot;Something went wrong&quot;</div></pre></td></tr></table></figure></p>
<p>现有对象方法赋值到某个变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let &#123; log, sin, cos &#125; = Math;</div></pre></td></tr></table></figure>
<p>解析出来的结果类似 <a href="http://babeljs.io/repl/#?evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Cstage-0&amp;code=let%20%7B%20log%2C%20sin%2C%20cos%20%7D%20%3D%20Math%3B" target="_blank" rel="external">代码</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">var log = Math.log;</div><div class="line">var sin = Math.sin;</div><div class="line">var cos = Math.cos;</div></pre></td></tr></table></figure></p>
<h6 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h6><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const [a, b, c, d, e] = &apos;hello&apos;;</div><div class="line">a // &quot;h&quot;</div><div class="line">b // &quot;e&quot;</div><div class="line">c // &quot;l&quot;</div><div class="line">d // &quot;l&quot;</div><div class="line">e // &quot;o&quot;</div></pre></td></tr></table></figure></p>
<p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let &#123;length : len&#125; = &apos;hello&apos;;</div><div class="line">len // 5</div></pre></td></tr></table></figure>
<h6 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h6><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let &#123;toString: s&#125; = 123;</div><div class="line">s === Number.prototype.toString // true</div><div class="line"></div><div class="line">let &#123;toString: s&#125; = true;</div><div class="line">s === Boolean.prototype.toString // true</div></pre></td></tr></table></figure></p>
<h6 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function add([x, y])&#123;</div><div class="line">    return x + y;</div><div class="line">&#125;</div><div class="line">add([1, 2]); // 3</div></pre></td></tr></table></figure>
<h5 id="解构赋值用途"><a href="#解构赋值用途" class="headerlink" title="解构赋值用途"></a>解构赋值用途</h5><h6 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="交换变量的值"></a>交换变量的值</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[x, y] = [y, x];</div></pre></td></tr></table></figure>
<h6 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 返回一个数组</div><div class="line">function example() &#123;</div><div class="line">    return [1, 2, 3];</div><div class="line">&#125;</div><div class="line">var [a, b, c] = example();</div><div class="line"></div><div class="line">// 返回一个对象</div><div class="line">function example() &#123;</div><div class="line">    return &#123;</div><div class="line">        foo: 1,</div><div class="line">        bar: 2</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">var &#123; foo, bar &#125; = example();</div></pre></td></tr></table></figure>
<h6 id="函数参数的定义"><a href="#函数参数的定义" class="headerlink" title="函数参数的定义"></a>函数参数的定义</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 参数是一组有次序的值</div><div class="line">function f([x, y, z]) &#123; ... &#125;</div><div class="line">f([1, 2, 3]);</div><div class="line"></div><div class="line">// 参数是一组无次序的值</div><div class="line">function f(&#123;x, y, z&#125;) &#123; ... &#125;</div><div class="line">f(&#123;z: 3, y: 2, x: 1&#125;);</div></pre></td></tr></table></figure>
<h6 id="提取JSON数据"><a href="#提取JSON数据" class="headerlink" title="提取JSON数据"></a>提取JSON数据</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var jsonData = &#123;</div><div class="line">id: 42,</div><div class="line">status: &quot;OK&quot;,</div><div class="line">data: [867, 5309]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let &#123; id, status, data: number &#125; = jsonData;</div><div class="line"></div><div class="line">console.log(id, status, number);</div><div class="line">// 42, &quot;OK&quot;, [867, 5309]</div></pre></td></tr></table></figure>
<h6 id="遍历Map结构"><a href="#遍历Map结构" class="headerlink" title="遍历Map结构"></a>遍历Map结构</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var map = new Map();</div><div class="line">map.set(&apos;first&apos;, &apos;hello&apos;);</div><div class="line">map.set(&apos;second&apos;, &apos;world&apos;);</div><div class="line"></div><div class="line">for (let [key, value] of map) &#123;</div><div class="line">console.log(key + &quot; is &quot; + value);</div><div class="line">&#125;</div><div class="line">// first is hello</div><div class="line">// second is world</div></pre></td></tr></table></figure>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 获取键名</div><div class="line">for (let [key] of map) &#123;</div><div class="line">// ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获取键值</div><div class="line">for (let [,value] of map) &#123;</div><div class="line">// ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h5><p>传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。</p>
<h6 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h6><p>返回布尔值，表示是否找到了参数字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var s = &apos;Hello world!&apos;;</div><div class="line"></div><div class="line">if(s.includes(&apos;ld&apos;)) &#123;</div><div class="line">    console.log(1)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith()"></a>startsWith()</h6><p>返回布尔值，表示参数字符串是否在源字符串的头部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s.endsWith(&apos;!&apos;) // true</div></pre></td></tr></table></figure>
<h6 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith()"></a>endsWith()</h6><p>返回布尔值，表示参数字符串是否在源字符串的尾部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s.endsWith(&apos;!&apos;) // true</div></pre></td></tr></table></figure>
<p>这三个方法都支持第二个参数，表示<code>开始</code>搜索的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const s = &apos;Hello world!&apos;;</div><div class="line">s.startsWith(&apos;world&apos;, 6) // true</div><div class="line">s.endsWith(&apos;Hello&apos;, 5);  // true</div><div class="line">s.endsWith(&apos;Hell&apos;, 4);   // true</div><div class="line">s.includes(&apos;Hello&apos;, 6)   // false</div></pre></td></tr></table></figure>
<h6 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 字符串中嵌入变量</div><div class="line">let name = &quot;Bob&quot;, time = &quot;today&quot;;</div><div class="line">console.log(`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`)</div></pre></td></tr></table></figure>
<p>模板字符串都是用  <strong>`</strong>, 也可以用来调用函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function add() &#123;</div><div class="line">    console.log(1222);</div><div class="line">&#125;</div><div class="line">let str = `Nihai $&#123;add()&#125;`;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;配置文件-babelrc&quot;&gt;&lt;a href=&quot;#配置文件-babelrc&quot; class=&quot;headerlink&quot; title=&quot;配置文件.babelrc&quot;&gt;&lt;/a&gt;配置文件.babelrc&lt;/h5&gt;&lt;p&gt;Babel的配置文件是&lt;code&gt;.babelrc&lt;/cod
    
    </summary>
    
      <category term="前端" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="https://hyb628.github.io/tags/ES6/"/>
    
      <category term="JavaScript" scheme="https://hyb628.github.io/tags/JavaScript/"/>
    
      <category term="数值" scheme="https://hyb628.github.io/tags/%E6%95%B0%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>BFC的理解与应用</title>
    <link href="https://hyb628.github.io/2016/06/06/BFC%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://hyb628.github.io/2016/06/06/BFC的理解与应用/</id>
    <published>2016-06-06T06:26:24.000Z</published>
    <updated>2017-04-29T12:03:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>题记：<br><br>在 CSS 面试中问 BFC 等概念，就如在 JS 面试中问闭包等概念一样，经常会刷掉一些真正优秀的人。 ——玉伯<br><br>今天突然想起之前找工作，李鹏大哥的一个面试题，问我什么是「BFC」，一脸茫然，这么专业的词语还真没听过？<br><br>不过，今天顺便自己理解这个东西，免得强迫症又犯了。<br><br>下面的全文部分载自 <a href="http://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html" target="_blank" rel="external">W3cplus</a>，总结的很好很详细，自己文章写了一点就不想写了，就直接转过来了。</blockquote><br><div id="wmd-preview-section-325" class="wmd-preview-section preview-content"><br><br>首先我们来看看w3c规范对BFC的解释，其实对于这种概念的学习上，我们总是建议首先寻找官方的定义，因为原则上来说官方的才是最权威和正确的，而且还比较详细，千万不要因为看到英文就畏惧不前。<br><h3>什么是BFC（Block formatting contexts）</h3><br><h4><a href="http://www.w3.org/TR/CSS2/visuren.html#block-formatting" target="_blank">w3c规范中的BFC定义</a>：</h4><br>浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。<br><br>在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。<br><br>在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。<br><h4>BFC的通俗理解：</h4><br>首先BFC是一个名词，是一个独立的布局环境，我们可以理解为一个箱子（实际上是看不见摸不着的），箱子里面物品的摆放是不受外界的影响的。转换为BFC的理解则是：BFC中的元素的布局是不受外界的影响（我们往往利用这个特性来消除浮动元素对其非浮动的兄弟元素和其子元素带来的影响。）并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。<br><div class="gg-ad clearfix"></div><br><h3>BFC的运用</h3><br>在w3c的规范中，除了上面的一段定义之外，BFC的相关知识点分布地比较零散，但基本集中在float、绝对定位、margin collaspe中。下面我们来看看如何应用到BFC来解决问题。<br><br>在很多网站中，我们经常会看到这样的一种，左边图片+右边信息的两栏结构，下面我们来看看如何利用BFC来实现。<br><br>首先我们给出这样的结构：<br><pre class="xml">//CSS<br>.box {width:210px;border: 1px solid #000;float: left;}<br>.img {width: 100px;height: 100px;background: #696;float: left;}<br>.info {background: #ccc;color: #fff;}<br>//HTML<br><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">“box”</span>&gt;</span><br>    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">“img”</span>&gt;</span>image<span class="tag">&lt;/<span class="title">div</span>&gt;</span><br>    <span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">“info”</span>&gt;</span>信息信息信息信息信息信息信息信息信息信息信息信<span class="tag">&lt;/<span class="title">p</span>&gt;</span><br><span class="tag">&lt;/<span class="title">div</span>&gt;</span></pre><br>一般情况下它呈现出我们所乐意看到的样子：<br><br><img src="http://cdn2.w3cplus.com/cdn/farfuture/Q6iFMA5vnDZtNG6srsImkOJB5j167fI0tlIMa_thU2A/mtime:1421034944/sites/default/files/styles/print_image/public/baiyaimages/margin-colla-4.jpg"><br><br>但随着文字信息增多后，会变地非常的糟糕：<br><br><img src="http://cdn2.w3cplus.com/cdn/farfuture/yr66_0XdtC7PJfqdbBFm4_jlwvwGULhtRMAQsYggOXw/mtime:1421034944/sites/default/files/styles/print_image/public/baiyaimages/margin-colla-5.jpg"><br><br>很明显，这是因为info类里面的文字受到了浮动元素的影响，但这并不是我们所期望的。此时我们可以为P元素的内容建立一个BFC，让其内容消除对外界浮动元素的影响。根据上文所知，只要给info元素添加overflow:hidden;即可为其内容建立新的BFC。当然你也可以通过其他方法来建立。其效果如下：<br><br><img src="http://cdn.w3cplus.com/cdn/farfuture/JBTWQM_Q1i52OvjZcE--T7bNl6IgLhu0a4Q4AV4tuDg/mtime:1421034945/sites/default/files/styles/print_image/public/baiyaimages/margin-colla-6.jpg"><br><h3>合并外边距与BFC</h3><br>在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。<br><h3>折叠的结果：</h3><br><ol><br>     <li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li><br>     <li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li><br>     <li>两个外边距一正一负时，折叠结果是两者的相加的和。</li><br></ol><br><h3>产生折叠的必备条件：margin必须是邻接的!</h3><br>而根据w3c规范，两个margin是邻接的必须满足以下条件：<br><ul><br>     <li>必须是处于常规文档流（非float和绝对定位）的<a href="http://www.w3.org/TR/CSS2/visuren.html#block-boxes" target="_blank">块级盒子</a>,并且处于同一个<a href="http://www.w3.org/TR/CSS2/visuren.html#block-formatting" target="_blank">BFC</a>当中。</li><br>     <li>没有线盒，没有空隙（<a href="http://www.w3.org/TR/CSS2/visuren.html#clearance" target="_blank">clearance</a>，下面会讲到），没有padding和border将他们分隔开</li><br>     <li>都属于垂直方向上相邻的外边距，可以是下面任意一种情况<br><ul><br>     <li>元素的margin-top与其第一个常规文档流的子元素的margin-top</li><br>     <li>元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top</li><br>     <li>height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom</li><br>     <li>高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottom</li><br></ul><br></li><br></ul><br><h3>以上的条件意味着下列的规则：</h3><br><ul><br>     <li>创建了新的BFC的元素（例如浮动元素或者’overflow’值为’visible’以外的元素）与它的子元素的外边距不会折叠</li><br>     <li><a href="http://www.w3.org/TR/CSS2/visuren.html#floats" target="_blank">浮动</a>元素不与任何元素的外边距产生折叠（包括其父元素和子元素）</li><br>     <li>绝对定位元素不与任何元素的外边距产生折叠</li><br>     <li>inline-block元素不与任何元素的外边距产生折叠</li><br>     <li>一个常规文档流元素的margin-bottom与它下一个常规文档流的兄弟元素的margin-top会产生折叠，除非它们之间存在间隙（clearance）。</li><br>     <li>一个常规文档流元素的margin-top 与其第一个常规文档流的子元素的margin-top产生折叠，条件为父元素不包含 padding 和 border ，子元素不包含 clearance。</li><br>     <li>一个 ‘height’ 为 ‘auto’ 并且 ‘min-height’ 为 ‘0’的常规文档流元素的 margin-bottom 会与其最后一个常规文档流子元素的 margin-bottom 折叠，条件为父元素不包含 padding 和 border ，子元素的 margin-bottom 不与包含 clearance 的 margin-top 折叠。</li><br>     <li>一个不包含border-top、border-bottom、padding-top、padding-bottom的常规文档流元素，并且其 ‘height’ 为 0 或 ‘auto’， ‘min-height’ 为 ‘0’，其里面也不包含行盒(line box)，其自身的 margin-top 和 margin-bottom 会折叠。</li><br></ul><br><strong><em>（下面我们对不产生折叠的情况逐一分析。）</em></strong><br><h4>浮动和绝对定位不与任何元素产生 margin 折叠</h4><br><strong>原因：</strong>浮动元素和绝对定位元素不与其他盒子产生外边距折叠是因为<strong>元素会脱离当前的文档流，违反了上面所述的两个margin是邻接的条件<strong>同时，又因为</strong>浮动和绝对定位会使元素为它的内容创建新的BFC</strong>，因此该元素和子元素所处的BFC是不相同的，因此也不会产生margin的折叠。<br><br><strong>DEMO：</strong><br><pre class="xml">//CSS<br>body {padding:0;margin: 0; text-align: center;}<br>.wrapper {margin:30px;width: 450px;border:1px solid red;}<br>.small-box {width: 50px;height: 50px;margin: 10px;background: #9cc;}<br>.middle-box {width: 100px;height: 100px;margin: 20px;background: #99c;}<br>.big-box {width: 120px;height: 120px;margin: 20px;background: #33e;}<br>.floatL {float: left;}<br>.floatR {float: right;}<br>.clear {clear: both;}<br>.posA {position: absolute;}<br>.overHid{overflow: hidden;}<br>.red {background: #f00;}<br>.green {background: #0f0;}<br>.blue {background: #00f;}<br>//HTML<br><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">“wrapper overHid”</span>&gt;</span><br>    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">“big-box blue”</span>&gt;</span>non-float<span class="tag">&lt;/<span class="title">div</span>&gt;</span><br>    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">“middle-box green floatL”</span>&gt;</span><br>        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">“small-box red”</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span><br>        float left<br>    <span class="tag">&lt;/<span class="title">div</span>&gt;</span><br><span class="tag">&lt;/<span class="title">div</span>&gt;</span></pre><br><img src="http://cdn1.w3cplus.com/cdn/farfuture/u_5R6bHOs4PnVTjbPcxoL4uYVQSgXAZ8PKWp5eul1sA/mtime:1421034944/sites/default/files/styles/print_image/public/baiyaimages/margin-colla-1.jpg"><br><br>但是浮动元素脱离了当前的BFC并不影响它后面的兄弟元素，后面的兄弟元素与浮动元素前面的元素依然在同一个BFC当中，所以，它们之间的margin还是会折叠的。下面我们对上面的demo做一下修改：<br><pre class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">“wrapper overHid”</span>&gt;</span><br>    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">“big-box”</span>&gt;</span>non-float<span class="tag">&lt;/<span class="title">div</span>&gt;</span><br>    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">“middle-box green floatL”</span>&gt;</span>float left<span class="tag">&lt;/<span class="title">div</span>&gt;</span><br>    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">“middle-box red”</span>&gt;</span>non-clear<span class="tag">&lt;/<span class="title">div</span>&gt;</span><br><span class="tag">&lt;/<span class="title">div</span>&gt;</span></pre><br><img src="http://cdn.w3cplus.com/cdn/farfuture/BcE8DVRuCZ0ykCGG4rHrtNyd8B9xWwOrnLBS2GzHGbU/mtime:1421034944/sites/default/files/styles/print_image/public/baiyaimages/margin-colla-2.jpg"><br><br>从上面这个修改后的demo中可以看出，红色的块盒在没有清楚浮动的情况下，它的margin-top和蓝色块盒的margin-bottom产生了折叠，这证明了我上面的结论。<br><br>下面我们来谈谈 <a href="http://www.w3.org/TR/CSS2/visuren.html#clearance" target="_blank">‘clearance’</a> 这个神奇的东西，当浮动元素之后的元素设置clear以闭合相关方向的浮动时，根据w3c规范规定，闭合浮动的元素会在其margin-top以上产生一定的空隙（clearance，如下图），该空隙会阻止元素margin-top的折叠，并作为间距存在于元素的margin-top的上方。关于这个间距的计算稍微有点复杂，但实际工作中你并不需要去计算它，我们先来看看例子吧：<br><pre class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">“wrapper overHid”</span>&gt;</span><br>    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">“big-box”</span> <span class="attribute">style</span>=<span class="value">“box-shadow:0 20px 0 rgba(0,0,255,0.2);”</span>&gt;</span>non-float<span class="tag">&lt;/<span class="title">div</span>&gt;</span><br>    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">“middle-box green floatL”</span> <span class="attribute">style</span>=<span class="value">“opacity:0.6”</span>&gt;</span>float left<span class="tag">&lt;/<span class="title">div</span>&gt;</span><br>    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">“middle-box red clear”</span> <span class="attribute">style</span>=<span class="value">“margin-top:40px;box-shadow:0 -40px 0 rgba(255,0,0,0.2);”</span>&gt;</span>clear<span class="tag">&lt;/<span class="title">div</span>&gt;</span><br><span class="tag">&lt;/<span class="title">div</span>&gt;</span></pre><br><img src="http://cdn2.w3cplus.com/cdn/farfuture/i8a8BoTw7r0VM_q1xZ_uX5dPybQw6gqTebBLQWnb8fs/mtime:1421034944/sites/default/files/styles/print_image/public/baiyaimages/margin-colla-3.jpg"><br><br>上面的图中我们可以看到，我们为红色块盒设置的40px的margin-top（这里我们通过相同高度的阴影来将其可视化）好像并没有对紫色块盒起作用，而且无论我们怎么修改这个margin-top值都不会影响红色块盒的位置，而只由绿色块盒的margin-bottom所决定。<br><br>也就是说，我们只需要知道，闭合浮动的元素的border-top会紧贴着相应的浮动元素的margin-bottom。<br><br>原来，通过w3c的官方规范可知，闭合浮动的块盒在margin-top上所产生的间距（clearance）的值与该块盒的margin-top之和应该足够让该块盒垂直的跨越浮动元素的margin-bottom，使闭合浮动的块盒的border-top恰好与浮动元素的块盒的margin-bottom相邻接。<br><br>用上图例子中的相关值可以得出这样一个式子：r-margin-top + r-clearance = g-margin-top + g-height + g-margin-bottom<br><br><em>PS！闭合浮动并不能使浮动元素回到原来的BFC当中！</em><br><h4>分析二：inline-block元素与其兄弟元素、子元素和父元素的外边距都不会折叠（包括其父元素和子元素）</h4><br>inline-block不符合w3c规范所说元素必须是<a href="http://www.w3.org/TR/CSS2/visuren.html#block-boxes" target="_blank">块级盒子</a>的条件，因为规范中又说明，块级盒子的display属性必须是以下三种之一：’block’， ‘list-item’， 和 ‘table’。<br><br><strong>参考资料</strong><br><ul><br>     <li><a href="http://www.w3.org/TR/CSS2/box.html" target="_blank">http://www.w3.org/TR/CSS2/box.html</a></li><br>     <li><a href="http://www.w3.org/TR/CSS2/visuren.html#block-formatting" target="_blank">http://www.w3.org/TR/CSS2/visuren.html#block-formatting</a></li><br>     <li><a href="http://www.w3.org/TR/CSS2/box.html#collapsing-margins" target="_blank">http://www.w3.org/TR/CSS2/box.html#collapsing-margins</a></li><br></ul><br>「<a href="http://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html" target="_blank" rel="external">出处</a>」<br><br></div><br><blockquote>这篇文章也总结的还不错 做个引用  <a href="http://www.ido321.com/1642.html" target="_blank" rel="external">http://www.ido321.com/1642.html</a></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;题记：&lt;br&gt;&lt;br&gt;在 CSS 面试中问 BFC 等概念，就如在 JS 面试中问闭包等概念一样，经常会刷掉一些真正优秀的人。 ——玉伯&lt;br&gt;&lt;br&gt;今天突然想起之前找工作，李鹏大哥的一个面试题，问我什么是「BFC」，一脸茫然，这么专业的词语还真没听过？
    
    </summary>
    
      <category term="前端" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="BFC" scheme="https://hyb628.github.io/tags/BFC/"/>
    
      <category term="CSS" scheme="https://hyb628.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记2</title>
    <link href="https://hyb628.github.io/2016/05/31/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>https://hyb628.github.io/2016/05/31/React学习笔记2/</id>
    <published>2016-05-31T12:05:11.000Z</published>
    <updated>2017-04-29T12:29:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>React学习笔记（一） 主要学习顶层API的东西，这里主要学习组件的生命周期东西，在这里做些笔记，免得自己健忘。<br>ReactDOM 提供了卸载组件的API，<code>ReactDOM.unmountComponentAtNode</code> 进行组件的移除或者卸载。</p>
<blockquote>
<p>StackOverflow 问答： <a href="http://dwz.cn/3tx3gJ" target="_blank" rel="external">http://dwz.cn/3tx3gJ</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var SampleComponent = React.createClass(&#123;</div><div class="line">    render: function() &#123;</div><div class="line">        return &lt;div&gt;Mounted component.&lt;/div&gt;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ReactDOM.render(&lt;SampleComponent /&gt;, document.getElementById(&apos;container&apos;));</div><div class="line"></div><div class="line">setTimeout(function() &#123;</div><div class="line">    ReactDOM.unmountComponentAtNode(document.getElementById(&apos;container&apos;));</div><div class="line">&#125;, 3000);</div></pre></td></tr></table></figure>
<p>有一点需要注意的是：React组件被卸载的时候，会触发<code>componentWillUnmount</code>，具体可以可以看下实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">var p = 0, timer;</div><div class="line">var HelloMessage = React.createClass(&#123;</div><div class="line">    render: function() &#123;</div><div class="line">        return &lt;h1&gt;一喵呜 &#123;this.props.name&#125;&lt;/h1&gt;;</div><div class="line">    &#125;,</div><div class="line">    componentWillMount: function () &#123;</div><div class="line">        console.log(&apos;componentWillMount&apos;);</div><div class="line">    &#125;,</div><div class="line">    getInitialState: function () &#123;</div><div class="line"></div><div class="line">        timer = setInterval(function () &#123;</div><div class="line">            p++;</div><div class="line">            console.log(p);</div><div class="line">            if (p === 3) &#123;</div><div class="line">                ReactDOM.unmountComponentAtNode(document.getElementById(&apos;example4&apos;) );</div><div class="line">            &#125;</div><div class="line">        &#125;,1000);</div><div class="line">        console.log(&apos;getInitialState&apos;);</div><div class="line">    &#125;,</div><div class="line">    componentDidMount: function () &#123;</div><div class="line">        console.log(&apos;componentDidMount&apos;);</div><div class="line">    &#125;,</div><div class="line">    componentWillUnmount: function() &#123;</div><div class="line">          clearInterval(timer);</div><div class="line">          console.log(&apos;卸载执行,清除计数器成功&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">ReactDOM.render(</div><div class="line">    &lt;HelloMessage name=&quot;BinJS&quot;/&gt;,</div><div class="line">    document.getElementById(&apos;example4&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<h4 id="查找组件"><a href="#查找组件" class="headerlink" title="查找组件"></a>查找组件</h4><p>react可以允许我们通过 <code>ref</code> 来定位一个组件。所以可以这样：<br>先给一个组件设置一个 <code>ref=‘xxx’</code> 的属性，注意这个<code>ref</code>必须是全局唯一的。</p>
<p>然后就可以通过 <code>this.refs.city</code> 来访问这个组件。但是获取到的组件是一个虚拟的DOM，因此才有了用<code>ReactDOM.fineDOMNode</code> 来获取一个真实的DOM节点，需要注意的是获取真实DOM需要在<code>render</code>之后才能获取成功，如果之前或者是没有这个DOM就返回 <code>null</code></p>
<h4 id="移动端触摸事件"><a href="#移动端触摸事件" class="headerlink" title="移动端触摸事件"></a>移动端触摸事件</h4><blockquote>
<p>v0.15版本之前开启移动端触摸事件需要这样：<br>进行移动开发时，渲染之前需要先调用React.initializeTouchEvents(true)，然后使用onTouchCancel onTouchEnd onTouchMove onTouchStart来进行触摸事件的开发</p>
</blockquote>
<p>v0.15 最新版本移除了这样的调用，直接用移动端事件就能用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">onTouchCancel onTouchEnd onTouchMove onTouchStart</div></pre></td></tr></table></figure>
<p>非DOM 属性 key 表单组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 文本框默认 &apos;hi&apos;  可以输入</div><div class="line">ReactDOM.render(&lt;input defaultValue=&quot;hi&quot; /&gt;, mountNode); </div><div class="line"></div><div class="line">// 文本框为空 可以输入</div><div class="line">ReactDOM.render(&lt;input value=&#123;undefined&#125; /&gt;, mountNode); </div><div class="line">ReactDOM.render(&lt;input /&gt;, mountNode); </div><div class="line"></div><div class="line">// 文本框默认 &apos;hi&apos;  只读状态 不能输入</div><div class="line">ReactDOM.render(&lt;input value=&apos;hi&apos;/&gt;, mountNode);</div></pre></td></tr></table></figure>
<ul>
<li>设置了 value 的 <code>&lt;input&gt;</code>是一个受限组件。 对于受限的 <code>&lt;input&gt;</code>，渲染出来的 HTML 元素始终保持 value 属性的值。</li>
<li>通过设置value为 <code>null</code> 或<code>undefined</code>或 通过设置一个<code>ref属性</code>，然后<code>this.refs</code> 获取到虚拟DOM进行修改value 或者是event.target.value</li>
<li>同样地， 类型为 <code>radio、checkbox 的&lt;input&gt;</code>支持 defaultChecked 属性， <code>&lt;select&gt;</code>支持<code>defaultValue</code> 属性。</li>
</ul>
<h4 id="受限组件"><a href="#受限组件" class="headerlink" title="受限组件"></a>受限组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var InputChangeValue  = React.createClass(&#123;</div><div class="line">      getInitialState: function () &#123;</div><div class="line">           return &#123;value: &apos;binjs&apos;&#125;;</div><div class="line">       &#125;,</div><div class="line">       handleChange: function (event) &#123;</div><div class="line">            console.log(event.target.value);</div><div class="line">            this.setState(&#123;value: event.target.value&#125;);</div><div class="line">            //this.setState(&#123;value: event.target.value.substr(0, 140)&#125;); // 限制140个字</div><div class="line">       &#125;,</div><div class="line">       render: function () &#123;</div><div class="line">          var value = this.state.value;</div><div class="line">          return(</div><div class="line">            &lt;div&gt;</div><div class="line">               &lt;input value=&#123;value&#125; onChange=&#123;this.handleChange&#125; /&gt;</div><div class="line">               &lt;p&gt;&#123;value&#125;&lt;/p&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">          )</div><div class="line">       &#125;</div><div class="line">  &#125;)</div><div class="line">  ReactDOM.render(</div><div class="line">      &lt;InputChangeValue /&gt;,</div><div class="line">      document.getElementById(&apos;example5&apos;)</div><div class="line">  )</div></pre></td></tr></table></figure>
<h4 id="不受限组件"><a href="#不受限组件" class="headerlink" title="不受限组件"></a>不受限组件</h4><p>没有设置 value的 (0.15版本之前 也可以设置null 就是不受限组件) <code>&lt;input&gt;</code>组件是一个不受限组件。对于不受限的 <code>&lt;input&gt;</code>组件，渲染出来的元素直接反应用户输入。</p>
<p>select 表单默认选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 单选 默认选中B 可编辑</div><div class="line"> &lt;select defaultValue=&quot;B&quot;&gt;</div><div class="line">    &lt;option value=&quot;A&quot;&gt;binjs&lt;/option&gt;</div><div class="line">    &lt;option value=&quot;B&quot;&gt;huangyb&lt;/option&gt;</div><div class="line"> &lt;/select&gt;</div><div class="line"></div><div class="line"> // 单选 默认选中B 不可编辑</div><div class="line"> &lt;select value=&quot;B&quot;&gt;</div><div class="line">   &lt;option value=&quot;A&quot;&gt;binjs&lt;/option&gt;</div><div class="line">   &lt;option value=&quot;B&quot;&gt;huangyb&lt;/option&gt;</div><div class="line"> &lt;/select&gt;</div><div class="line"></div><div class="line">// 设置多选 默认选中B C  可编辑</div><div class="line">&lt;select multiple=&#123;true&#125; defaultValue=&#123;[&apos;B&apos;, &apos;C&apos;]&#125;&gt;</div><div class="line">  &lt;option value=&quot;A&quot;&gt;binjs&lt;/option&gt;</div><div class="line">  &lt;option value=&quot;B&quot;&gt;huangyb&lt;/option&gt;</div><div class="line">  &lt;option value=&quot;C&quot;&gt;huang&lt;/option&gt;</div><div class="line">&lt;/select&gt;</div></pre></td></tr></table></figure>
<h4 id="通过-AJAX-加载初始数据"><a href="#通过-AJAX-加载初始数据" class="headerlink" title="通过 AJAX 加载初始数据"></a>通过 AJAX 加载初始数据</h4><p>在 <code>componentDidMount</code> 时加载数据。当加载成功，将数据存储在 state 中，触发 render 来更新你的 UI。当执行异步请求的响应时，在更新 state 前， 一定要先通过 <code>this.isMounted()</code>来检测组件的状态是否还是 mounted。<a href="ttp://reactjs.cn/react/tips/initial-ajax.html" target="_blank" rel="external">React initial-ajax doc</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React学习笔记（一） 主要学习顶层API的东西，这里主要学习组件的生命周期东西，在这里做些笔记，免得自己健忘。&lt;br&gt;ReactDOM 提供了卸载组件的API，&lt;code&gt;ReactDOM.unmountComponentAtNode&lt;/code&gt; 进行组件的移除或者卸
    
    </summary>
    
      <category term="前端" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://hyb628.github.io/tags/JavaScript/"/>
    
      <category term="JSX" scheme="https://hyb628.github.io/tags/JSX/"/>
    
      <category term="React" scheme="https://hyb628.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记1</title>
    <link href="https://hyb628.github.io/2016/05/27/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>https://hyb628.github.io/2016/05/27/React学习笔记1/</id>
    <published>2016-05-27T12:35:24.000Z</published>
    <updated>2017-04-29T12:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>打算对React的学习过程 分阶段性的学习和总结吧，先把这周主要看的学的知识点做个记录，后期慢慢学到新的东西慢慢整理起来。刚开始比较生疏，难免有问题。</p>
</blockquote>
<h4 id="ReactDOM-render"><a href="#ReactDOM-render" class="headerlink" title="ReactDOM.render"></a>ReactDOM.render</h4><p><code>ReactDOM.render</code> 里面 逗号分隔 最后面不要不要标点符号 ,<code>ReactDOM.render</code> 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(element, container, callback) // 回调函数，可选。传入该值时，会在组件渲染完或更新完成后调用</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  &lt;h1&gt;huangyb&lt;/h1&gt;,</div><div class="line">  document.getElementById(&apos;example&apos;)</div><div class="line">)</div></pre></td></tr></table></figure>
<h4 id="chrome-扩展程序"><a href="#chrome-扩展程序" class="headerlink" title="chrome 扩展程序"></a>chrome 扩展程序</h4><ul>
<li><a href="http://dwz.cn/3svSWa" target="_blank" rel="external">扩展程序React Developer Tools</a></li>
<li><a href="http://dwz.cn/3svU59" target="_blank" rel="external">react-detector</a></li>
</ul>
<h4 id="React版本说明"><a href="#React版本说明" class="headerlink" title="React版本说明"></a>React版本说明</h4><p>写react 需要引入三个JS文件 <code>react.js</code> 、  <code>eacr-dom.js</code> 、  <code>browser.min.js</code>  （0.14版本之前合并为一个文件，0.14版本以上就拆分为三个文件）</p>
<blockquote>
<p>React CDN:</p>
<ul>
<li><a href="http://cdn.bootcss.com/react/15.1.0/react.min.js" target="_blank" rel="external">http://cdn.bootcss.com/react/15.1.0/react.min.js</a></li>
<li><a href="http://cdn.bootcss.com/react/15.1.0/react-dom.js" target="_blank" rel="external">http://cdn.bootcss.com/react/15.1.0/react-dom.js</a></li>
<li><a href="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js" target="_blank" rel="external">https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js</a></li>
</ul>
</blockquote>
<p>页面中用 <code>&lt;script type=&quot;text/babel&quot;&gt;</code>标记来使用 JSX 转换器.在以前旧版本的只有一个<code>react.js</code> 文件 所以假如 <code>React.render</code> 相当于现在新版本的 <code>ReactDOM.render</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(&lt;div&gt;&#123;name&#125;&lt;/div&gt; ,document.getElementById(&apos;id&apos;))</div></pre></td></tr></table></figure>
<p>需要有个Root父级元素包裹，不能插入的数据是多个同级，不然会报错。</p>
<h4 id="render的两种方式"><a href="#render的两种方式" class="headerlink" title="render的两种方式"></a>render的两种方式</h4><ul>
<li>JSX 的基本语法规则：遇到 HTML 标签（以 <code>&lt;</code> 开头），就用 HTML 规则解析；遇到代码块（以 <code>{</code> 开头），就用 JavaScript 规则解析。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var name2 = [&apos;y1&apos;,&apos;y2&apos;,&apos;y3&apos;];</div><div class="line">ReactDOM.render( </div><div class="line">	&lt;div&gt; &#123; name2.map(function (key) &#123; return &lt;li&gt;&#123;key&#125;&lt;/li&gt; &#125;) &#125; &lt;/div&gt;, </div><div class="line">	document.getElementById(&apos;name22&apos;) </div><div class="line">)</div></pre></td></tr></table></figure>
<ul>
<li>JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var arr = [</div><div class="line">   &lt;h1&gt;Hello world!&lt;/h1&gt;,</div><div class="line">   &lt;h2&gt;React is awesome&lt;/h2&gt;</div><div class="line">];</div><div class="line">ReactDOM.render(</div><div class="line">   &lt;div&gt;&#123;arr&#125;&lt;/div&gt;,</div><div class="line">   document.getElementById(&apos;example&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<blockquote>
<p>JSX = JavaScriptXML</p>
</blockquote>
<h4 id="React-createClass"><a href="#React-createClass" class="headerlink" title="React.createClass"></a>React.createClass</h4><p>React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。<code>React.createClass</code> 方法就用于生成一个组件类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;con&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;script type=&quot;text/babel&quot;&gt;</div><div class="line">  var HelloMess = React.createClass(&#123;</div><div class="line">    render: function () &#123;</div><div class="line">        return &lt;p className=&quot;pp&quot;&gt;huangyb &#123;this.props.yb&#125;&lt;/p&gt;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  ReactDOM.render(</div><div class="line">      &lt;HelloMess yb=&quot;你好&quot;&gt;&lt;/HelloMess&gt;,</div><div class="line">      document.getElementById(&apos;con&apos;),function () &#123;</div><div class="line">          console.log(&apos;render完成&apos;);</div><div class="line">      &#125;</div><div class="line">  )</div></pre></td></tr></table></figure>
<h4 id="HTML-标签-vs-React-组件"><a href="#HTML-标签-vs-React-组件" class="headerlink" title="HTML 标签 vs. React 组件"></a>HTML 标签 vs. React 组件</h4><ul>
<li>React.render方法可以渲染HTML结构，也可以渲染React组件。渲染HTML标签，声明变量采用首字母小写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var myDivElement = &lt;div className=&quot;foo&quot; /&gt;;</div><div class="line">React.render(myDivElement, document.body);</div></pre></td></tr></table></figure>
<ul>
<li>渲染React组件，声明变量采用首字母大写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var MyComponent = React.createClass(&#123;/*...*/&#125;);</div><div class="line">var myElement = &lt;MyComponent someProperty=&#123;true&#125; /&gt;;</div><div class="line">React.render(myElement, document.body);</div></pre></td></tr></table></figure>
<h4 id="HTML转义"><a href="#HTML转义" class="headerlink" title="HTML转义"></a>HTML转义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var htmlEle = &quot;&lt;strong&gt;htmlEle&lt;/strong&gt;&quot;;</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">    &lt;HybNode&gt;</div><div class="line">        &lt;div&gt;HTML转义情况::&#123;htmlEle&#125;&lt;/div&gt;</div><div class="line">        &lt;div dangerouslySetInnerHTML=&#123;&#123;__html: htmlEle&#125;&#125; data-hyb=&quot;xxx&quot; aria-ybs=&quot;true&quot;/&gt;</div><div class="line">    &lt;/HybNode&gt;,</div><div class="line">    document.getElementById(&apos;example3&apos;)</div><div class="line">)</div></pre></td></tr></table></figure>
<h4 id="className-和-htmFor-的使用"><a href="#className-和-htmFor-的使用" class="headerlink" title="className 和 htmFor 的使用"></a>className 和 htmFor 的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#使用JSX</div><div class="line">ReactDOM.render(</div><div class="line">        &lt;label className=&quot;xxx&quot; htmlFor=&quot;input&quot;&gt;content&lt;/label&gt;,</div><div class="line">        document.getElementById(&apos;example&apos;)</div><div class="line">);</div><div class="line"></div><div class="line">#不使用JSX</div><div class="line">ReactDOM.render(</div><div class="line">        React.createElement(&apos;label&apos;, &#123;className: &apos;xxx&apos;, htmlFor: &apos;input&apos;&#125;, &apos;content&apos;),</div><div class="line">        document.getElementById(&apos;example&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
<h4 id="js表达式"><a href="#js表达式" class="headerlink" title="js表达式"></a>js表达式</h4><ul>
<li>表达式用{}包起来，不要加引号，加引号就会被当成字符串。</li>
<li>JSX是HTML和JavaScript混写的语法，当遇到&lt;，JSX就当HTML解析，遇到{就当JavaScript解析。</li>
</ul>
<p>属性表达式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render( </div><div class="line"> &lt;div className=&#123;2 &gt; 1 ? &apos;class-a&apos; : &apos;class-b&apos;&#125;&gt;content&lt;/div&gt;, </div><div class="line"> document.body </div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>子表达式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var Nav = React.createClass(&#123;</div><div class="line">   render: function () &#123;</div><div class="line">   return &lt;div&gt;nav&lt;/div&gt;</div><div class="line"> &#125;</div><div class="line">&#125;);</div><div class="line">ReactDOM.render(</div><div class="line">   &lt;div&gt;</div><div class="line">     &#123;2 &gt; 1 ? &lt;Nav/&gt; : &lt;div&gt;div&lt;/div&gt;&#125;</div><div class="line">   &lt;/div&gt;,</div><div class="line">   document.body</div><div class="line">);</div></pre></td></tr></table></figure>
<blockquote>
<p>注释, 同JS注释一样： 单行： <code>//</code>    多行： <code>/**/</code></p>
</blockquote>
<h4 id="JSX延伸属性"><a href="#JSX延伸属性" class="headerlink" title="JSX延伸属性"></a>JSX延伸属性</h4><p>为了解决手动添加属性造成的类型错误，React设定初始化完props后，props是不可改变的。为了解决这个问题，React引入了属性延伸。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var props = &#123;&#125;;</div><div class="line">props.foo = x;</div><div class="line">props.bar = y;</div><div class="line">var component = &lt;Component &#123;...props&#125; /&gt;;</div></pre></td></tr></table></figure>
<p>当需要拓展我们的属性的时候，定义一个属性对象，并通过{…props}的方式引入，React会帮我们拷贝到组件的props属性中。重要的是—这个过程是由React操控的，不是手动添赋值的属性。<br>需要覆盖的时候可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var defaultStyle = &#123;   // 这两种方法写样式都能显示 ，但是还是用小驼峰的写法推荐</div><div class="line">  &apos;font-size&apos;:&apos;20px&apos;,</div><div class="line">  &apos;listStyleType&apos;:&apos;none&apos;</div><div class="line">&#125;</div><div class="line">var NodeList = React.createClass(&#123;</div><div class="line">    render: function()&#123;</div><div class="line">        return(</div><div class="line">            &lt;ol&gt;</div><div class="line">              &#123;</div><div class="line">                  React.Children.map(this.props.children, function(child)&#123;</div><div class="line">                      return &lt;li style=&#123;defaultStyle&#125;&gt;&#123;child&#125;&lt;/li&gt;</div><div class="line">                  &#125;)</div><div class="line">              &#125;</div><div class="line">            &lt;/ol&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">ReactDOM.render(</div><div class="line">   &lt;NodeList&gt;</div><div class="line">      &lt;span&gt;23&lt;/span&gt;</div><div class="line">      &lt;span&gt;88&lt;/span&gt;</div><div class="line">   &lt;/NodeList&gt;,</div><div class="line">   document.getElementById(&apos;example2&apos;)</div><div class="line">)</div></pre></td></tr></table></figure>
<h4 id="style属性"><a href="#style属性" class="headerlink" title="style属性"></a>style属性</h4><p>在React中写行内样式时，要这样写，不能采用引号的书写方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">    &lt;div style=&#123;&#123;color:&apos;red&apos;&#125;&#125;&gt;</div><div class="line">        xxxxx</div><div class="line">    &lt;/div&gt;,</div><div class="line">    document.body</div><div class="line">);</div></pre></td></tr></table></figure>
<h4 id="自定义HTML属性"><a href="#自定义HTML属性" class="headerlink" title="自定义HTML属性"></a>自定义HTML属性</h4><p> <code>data-*</code> 、<code>aria-*</code></p>
<p> 如果在编写React过程中往原生HTML标签中使用了自定义属性，React不会渲染的<br>【然而任意属性支持自定义元素 】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">    &lt;div data-dd=&apos;xxx&apos; aria-dd=&apos;xxx&apos;&gt;content&lt;/div&gt;,</div><div class="line">    document.body</div><div class="line">);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;打算对React的学习过程 分阶段性的学习和总结吧，先把这周主要看的学的知识点做个记录，后期慢慢学到新的东西慢慢整理起来。刚开始比较生疏，难免有问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;ReactDOM-render&quot;&gt;&lt;a hr
    
    </summary>
    
      <category term="前端" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://hyb628.github.io/tags/JavaScript/"/>
    
      <category term="JSX" scheme="https://hyb628.github.io/tags/JSX/"/>
    
      <category term="React" scheme="https://hyb628.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>CSS Hack、JS userAgent</title>
    <link href="https://hyb628.github.io/2016/05/25/csshack-jsagent/"/>
    <id>https://hyb628.github.io/2016/05/25/csshack-jsagent/</id>
    <published>2016-05-25T12:56:55.000Z</published>
    <updated>2017-04-29T13:07:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>摘要：项目中刚好遇到一个样式问题，win10版本的IE11、Edge跟我win8系统IE11浏览器出现了不同程度的样式差异，假如有一像素偏差吧。实在是没辙了，想单纯用CSS去解决，在不动用JS情况下，找了好久的资料，试了几次，发现国外一个大牛写的不错。就整理下。</p>
</blockquote>
<p>HACK：</p>
<ul>
<li><a href="http://browserhacks.com/" target="_blank" rel="external">browserhacks</a></li>
<li><a href="https://browserstrangeness.bitbucket.io/css_hacks.html?" target="_blank" rel="external">browserstrangeness</a></li>
</ul>
<p>具体内容自己看比较省事，遇到问题有针对性的去解决。</p>
<p>不过，一开始找到的解决我的问题，在<a href="http://stackoverflow.com/search?q=CSS+hack" target="_blank" rel="external">stackoverflow</a>上针对CSS hack的回答一个个找好心累，试了又不一定成功，所以就这么搞了，最终找到一个合适的，没办法，业务的东西，只能用hack。</p>
<p>面整理一个侦测IE的Javascript，目前最高支援到IE12。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function isIEVersion() &#123;</div><div class="line">    var ua = window.navigator.userAgent;</div><div class="line">    var msie = ua.indexOf(&apos;MSIE &apos;);</div><div class="line">    if (msie &gt; 0) &#123;</div><div class="line">        // 回傳版本 &lt;=10 的版本</div><div class="line">        return parseInt(ua.substring(msie + 5, ua.indexOf(&apos;.&apos;, msie)), 10);</div><div class="line">    &#125;</div><div class="line">    var trident = ua.indexOf(&apos;Trident/&apos;);</div><div class="line">    if (trident &gt; 0) &#123;</div><div class="line">        // 回傳版本 &gt;=11 的版本</div><div class="line">        var rv = ua.indexOf(&apos;rv:&apos;);</div><div class="line">        return parseInt(ua.substring(rv + 3, ua.indexOf(&apos;.&apos;, rv)), 10);</div><div class="line">    &#125;</div><div class="line">    var edge = ua.indexOf(&apos;Edge/&apos;);</div><div class="line">    if (edge &gt; 0) &#123;</div><div class="line">        // 判斷Edge</div><div class="line">        return parseInt(ua.substring(edge + 5, ua.indexOf(&apos;.&apos;, edge)), 10);</div><div class="line">    &#125;</div><div class="line">    // other browser</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>2016.5.27  更新</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.ui-select-options &#123; </div><div class="line">  min-width: 85px\0;</div><div class="line">&#125; </div><div class="line">/*9-11*/ </div><div class="line">_::selection, .ui-select-options &#123; </div><div class="line">  min-width: auto\0; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>处理完后，遇到IE8的下拉问题，接着遇到IE8刷新报错的问题，这个真叫棘手问题。测试开发环境是打包的代码，所有很难找到具体什么原因，只提示一个ECUI.js undefined问题，无奈把测试环境的打包代码都干掉 ，部署本地未打包的源码上去 一个个功能模块去测试，最后，发现是日期组件的问题。只能联系成都的小伙伴看看，叫写组件的看看，确实不是我这边代码问题后，只能修改ECUI.js 做容错处理。</p>
<p>OK，大神就是大神，确定问题后，只能打包构建提测吧，每次总觉得 一到晚上 测试总会给我来个Bug，让我都担心受怕的。这都周五了，我想静静！还指望周末打个球。</p>
<p>早上在修改测试环境的时候，准备把一个文件夹下面的所有文件移到上级目录的时候，因为键盘数字键盘关了，导致 <code>mv * ../</code> 变成了 <code>mv * /</code>， My Gold，都跑到根目录下了。无奈只能一个个删除咯。</p>
<p>safari浏览器判断:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (navigator.userAgent.indexOf(&apos;Mac OS X&apos;) &gt; 0 &amp;&amp; navigator.userAgent.indexOf(&apos;Safari&apos;) &gt; -1 &amp;&amp;  navigator.userAgent.indexOf(&apos;Chrome&apos;) &lt; 0) &#123;</div><div class="line">     // code</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不判断Chrome的话会跟Mac下安装的Chrome 和 QQ浏览器混淆，因为在Mac下QQ浏览器返回userAgent：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.82 Safari/537.36 QQBrowser/4.0.4035.400&quot;</div></pre></td></tr></table></figure>
<p>Chrome在Mac返回的userAgent信息是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36&quot;</div></pre></td></tr></table></figure></p>
<p>FireFox在Mac下返回的userAgent信息是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:45.0) Gecko/20100101 Firefox/45.0&quot;</div></pre></td></tr></table></figure></p>
<p>Opera在Mac下返回的userAgent信息是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36 OPR/36.0.2130.65&quot;</div></pre></td></tr></table></figure></p>
<p>所以判断有没有Chrome这个关键字就能判断是不是Mac下Safari了。</p>
<blockquote>
<p>2016.5.27  pm 更新</p>
</blockquote>
<p>发现测试人员用了一个软件挺有意思的，<a href="http://oldj.github.io/SwitchHosts/" target="_blank" rel="external">SwitchHost</a> 推荐一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要：项目中刚好遇到一个样式问题，win10版本的IE11、Edge跟我win8系统IE11浏览器出现了不同程度的样式差异，假如有一像素偏差吧。实在是没辙了，想单纯用CSS去解决，在不动用JS情况下，找了好久的资料，试了几次，发现国外一个大牛写的不
    
    </summary>
    
      <category term="前端" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="https://hyb628.github.io/tags/CSS/"/>
    
      <category term="Hack" scheme="https://hyb628.github.io/tags/Hack/"/>
    
      <category term="userAgent" scheme="https://hyb628.github.io/tags/userAgent/"/>
    
  </entry>
  
  <entry>
    <title>阶段性技术啰嗦（一）</title>
    <link href="https://hyb628.github.io/2016/05/20/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%8A%80%E6%9C%AF%E5%95%B0%E5%97%A61/"/>
    <id>https://hyb628.github.io/2016/05/20/阶段性技术啰嗦1/</id>
    <published>2016-05-20T06:26:24.000Z</published>
    <updated>2017-04-29T08:31:42.000Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=17579515&auto=1&height=66"></iframe>

<p>听听有情怀的歌，陶冶情操！大学很爱的一首歌。</p>
<p>又到周五了，趁现在下班时间，抽空写写最近在公司遇到的坑以及学到的东西吧，最近一直很少做自己的技术总结，老是写生活随笔啥的似乎也不符合我这个愤青的年龄 。看到我都觉得我活在小康社会似的，我都快不相信自己了。</p>
<p>最近一直在做支付项目，公司用到了百度ECUI的一个MVC框架，配合<code>ETpl模板引擎</code>，后台是Java语言，开始做<a href="http://2014.jsconf.cn/slides/herman-taobaoweb/#/1" target="_blank" rel="external">前后端分离</a></p>
<p>毕竟第一次做，难免有些紧张。(~.~)，讲讲几个遇到的问题以及解决办法吧，俗话说，找到合适的途径 合适的方法才是做重要的。因为在公司没写完就回来了，所以深夜还是继续写，当日事当日毕。</p>
<h5 id="ETpl"><a href="#ETpl" class="headerlink" title="ETpl"></a>ETpl</h5><p>说说ETpl吧，一个百度模板引擎，虽然用到人不是很多，但是大致还是一样的吧 通用模板都是大致类似，一开始遇到的问题还是挺多的，因为模板在项目或者是组件都是很多封装或者是写好的，需要什么就哪来用，不过，多多少少还是会有问题的，比如兼容性或者是可能这个组件不适用今后的产品升级，那就需要更新这个组件，但是你会发现，组件是很多地方在通用，所以你很多东西你不能乱动的，就怕会牵一发而动全身。</p>
<p>但是这不是我要考虑的事情，我要做的就是把功能做好，或者做出来吧 现阶段。先熟悉熟悉框架或者是别人的代码，一开始没啥经验，也没比较全面的文档，或者是教程，很多都是需要你去看别人的代码或者是代码去运行了你才能懂这个功能到底是干嘛用的。刚开始前几天确实没头绪，蒙了，有点想放弃，但是想想别人大都是这么过来的，自己就是吃翔也得坚持下来对吧?</p>
<h5 id="ECUI"><a href="#ECUI" class="headerlink" title="ECUI"></a>ECUI</h5><p>ECUI实现MVC的一些业务实现控件化，就是希望做到每个功能能够组件化吧。不过写组件的我都觉得很佩服，是我需要学习的前辈们。</p>
<p>入职第一天，我的导师—— 我的师傅，挺不错的，我见过的很勤奋的一个女前端，得叫全栈，因为他们都是Java转的前端，来抢前端的饭碗的女中豪杰，还有超哥和浩哥都是这里的一员。吃饭都是各成一派，我要是想吃面食就跟浩哥走，想吃盖饭啥的就跟超哥走。就是这么随波逐流，没办法。</p>
<p>一开始，需要知道的东西比较多，所以比较乱，毕竟从外包公司出来的，所以很多东西还是比较不规范需要去加强学习的。先来说说Git吧，耳熟能详的东西。</p>
<p>按照以往的做法，以往我们都是直接在Master提交代码，或者是SVN，那时候还不是命令那么高端，都是客户端可视化，所以直接更新或者是检出提交，所以总出现各种问题，在外包的时候，你需要跟着客户的节奏走，赶时间赶项目，时间一紧张就会频繁遇到问题。小项目还好，但是遇到大项目估计就不行了这种办法。</p>
<p>来了公司之后，开始熟悉下运作流程，提交代码都是各种需要权限，我自己建一个分支，然后开始开发了，每次提交代码都需要别人的代码审核或者叫review，没问题给你通过代码审核，你可能push成功上去，不行就给你打回去，你就需要重新git reset 到成功的那个版本（changeId） ，假如通过了，那还不一定就完事了，代码是使用<em>Jenkin</em>s配置自动化构建，自动代码检查和压缩打包之类的，你得看是不是有报错，所以没问题才能继续通过SSH上传到开发环境。一开始我又蒙了，什么鬼啊这是？一直出问题，代码报错，因为你JS不书写规范或者是CSS 不书写规范都会构建不成功（比如function后面需要空格或者是改空格就空格，分号啥的都要按照书写规范，一开始有个功能用到Tab切换，我用到的时候闭包去写切换，然后又是报错，我实在没辙了），最后师傅叫我安装本地的JSSLint 和 CSSLint ，OK 安装就安装呗，没想到，又是遇到问题来了。我之前Sublime安装了各种插件，所以一直安装不成功，因为公司用的CSSLint 和 JSLint 的校验包都是有了，我需要用Node安装着两个，然后替换这两个文件夹，后台我把我心爱的插件都删了，重新安装了CSSLint 和 JSLint 就可以了，真是纠结死我了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.安装nodejs最新版本，通过nodejs指令 cmd下执行npm install -g xxx分别安装jslint与csslint</div><div class="line">npm install -g jslint</div><div class="line">npm install -g csslint</div><div class="line">2.安装Sublime Text 3(推荐，也可以安装别的工具)，安装Package Control</div><div class="line">3.通过Package Control安装SublimeLinter/SublimeLinter-contrib-jslint/SublimeLinter-csslint</div><div class="line">  ctrl + shift + p---&amp;gt;install package</div><div class="line">4.执行jslint找到jslint的安装目录的父目录，使用我提供的jslint/csslint包覆盖掉原来的jslint与csslint</div></pre></td></tr></table></figure>
<p>安装完这两个东西，把所有的文件报错都修改了 ，再Git命令push,review进行审核，哦哦，原来如此，不过真是折腾死宝宝 了(づ｡◕‿‿◕｡)づ  我不能放弃吃药才行！</p>
<h5 id="Fiddler代理"><a href="#Fiddler代理" class="headerlink" title="Fiddler代理"></a>Fiddler代理</h5><p>也是知道原来用这个来做前后端分离，假如后台是Java或者是项目是基于后台的Java 我就想到头疼的需要各种配置后台环境，用Fiddler 写正则判断，实现本地走代理，不过需要配置本地的HOST文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">regex:https://hyb628.github.io/(.*).(html|js|css|less|js_|jpg|png)(\?[a-zA-Z0-9]+=[0-9A-Za-z]*)?$</div></pre></td></tr></table></figure>
<p>这样我就把需要的资源就不走外网直接走本地，不过https链接本地打开的话每次都提示证书问题确实比价烦，需要把s去掉就好，第一次资源加载进来在打开代理加载规则，加上用用框架的，视图层 和 数据逻辑都分开配合使用，加上ECUI的路由addRoute 控制实现类似单页面的不刷新页面跳转差不多这个意思。也可以用callRoute调用路由，哦哦，原来这样啊。</p>
<p>前端交互之前一直没在做这块，所以，后端专心写他们的接口就好了，前端也不用去管他们用什么环境，前端该怎么开发就怎么开发，完全独立出来。各自负责自己的业务吧。</p>
<p>后台写好接口需要前后端联调，好吧，我确实没做过这块，所以，又得跟后台大哥去做配合联调，一开始可能他们写的接口有问题那就慢慢对接，我照样开发，我需要什么参数叫后台给我提供好，或者看需求文档，不过，需求文档这东西，要是产品经理写的没那么详细，那估计你又得去撩妹，找找她们说说哪里不行怎么做好了。也很费神。</p>
<p>需求文档包含埋点的增加，就是类似数据监控吧。我开发完才去加这些 不过还算简单，期间，PPT和PSD 都给到你了，不过PSD比较不好找，估计时间比较赶吧设计师，有点糙，不过也没事，反正我是切图仔，专业抠图20年（顺带抠脚）。</p>
<p>开发完一个功能，因为涉及到跟JSP的页面跳转，因为毕竟可能有些老代码的话那就不可能一下子都改革过来都是慢慢更新迭代，就涉及到比如页面的跳转，也是需要用路由的方式，发个请求跟JSP那个大哥协商好发什么东西给他我页面才能跳转到正确页面，也蛮有意思的。</p>
<h5 id="SSH-（Xshell）代码部署"><a href="#SSH-（Xshell）代码部署" class="headerlink" title="SSH （Xshell）代码部署"></a>SSH （Xshell）代码部署</h5><p>我通过Jenkins 构建成功的话，需要进行打包，因为一开始构建我遇到一直打包不成功的问题，后来各种找问题，才发现我的LESS文件里面import了其他功能的LESS ，导致那个文件编译了，我的LESS就被output 丢弃了。所以搞得我都直播吃翔了。一开始以为LESS书写不规范或者是哪里问题，各种修改，各种蛋疼，就取消嵌套规则，结果还是不行，后台请教了文浩大哥，他第二天早上去看了看打包工具的源码，才发现是我的import问题，删掉结果就成功了，那时候，感动的鼻涕鼻屎都快出来了（没那么夸张，有点夸张，就是比较激动吧）。</p>
<p>成功后，下载打包成功的代码包，准备部署到测试环境了，这下师傅跟我说你用Xshell工具进行部署，问我会不会LINUX的一些命令，我这下又懵逼了，我说不会，我说你演示我看看，我记一下，结果，上面很多文件夹还是有权限的，一开始给我部署时候，进行代码全部覆盖，其实我都看不懂，比较笨呗，最后，暗自下决心开始学习基本命令，因为Mac几个简单命令还是稍微知道，要是这种 .tar.gz 打包好，先rz命令上传文件包，上传然后用 -zxvf   web-fe-XXXX.tar.gz ( Tab键可补全文件名)   解压文件，然后再改改一个配置文件，就好了，第二天，我做了笔记自己尝试了下，觉得还行，像文件的删除，移动，或者是解压命令用几次就熟悉啦。也就能实现自己去部署代码啦。</p>
<h5 id="CO提测"><a href="#CO提测" class="headerlink" title="CO提测"></a>CO提测</h5><p>以前写代码，假如有测试人员，貌似都是后台部署然后测试进行测试吧，怎么测试我就不懂啦。现在需要做的就是进行提交测试申请，加入后端写接口的 他们也自己提交自己的测试申请，前端自己开发的提交自己Git分支的测试申请，通过网站，把构建好的源码包上传，还有需要写README文件，大致内容告诉测试人员提测点，需要测试哪些功能，他们好进行测试，还有就是你修改的哪些文件，这样他们测试的时候，直接抓取那个修改的文件过来就好，不至于整个项目进行替换，还有自己也写写备注自己修改了哪些文件，自己好知道。还有重要的一点就是，写提测点文件需要附上后台接口地址这样他们测试人员好对照接口进行测试，还有，因为埋点前端自己加，所以加了哪些也得提测前写到通用的线上文档里面，写完了测试申请说明和文件就提交上去啦，只是第一轮提测，期间测试人员通过禅道进行测试Bug反馈，不过，我拿到我的禅道账号打开一看，再次懵逼了，里面的项目多的我都找不到我的项目属于哪个，最后才知道我需要问问测试人员测试项目的版本号，每进行一个小功能测试都有测试版本号，加入这个版本号测试完了，你去修改Bug 改完了后继续提交第二轮测试，貌似好几轮测试。都不容易啊。<del>~~(&gt;_&lt;)</del>~~</p>
<h5 id="浅谈Bug"><a href="#浅谈Bug" class="headerlink" title="浅谈Bug"></a>浅谈Bug</h5><p>说下遇到的一个之前没遇到过的Bug吧，就是tbody用JS的innerHTML插入，在IE9- 不支持，因为IE的只读模式所以出现未知的报错， <a href="http://stackoverflow.com/questions/4729644/cant-set-innerhtml-on-tbody-in-ie" target="_blank" rel="external">问题描述</a>， 尝试后发现过于复杂并且不使用这个模板渲染方式，所以最后不得不换用li 标签之类的修改。加上模板引擎就不好做处理，所以需要谨慎用table标签吧。</p>
<p>涉及到的知识点有： 加入我用callRoute调用路由的方式进行页面的参数附带在浏览器上数据重新渲染，那还好，但是，我实现的是JS的重新渲染数据，所以这里就遇到瓶颈，纠结了一晚上最后还是决定改标签了。数据逻辑还是需要考虑全面一点才行。</p>
<p>今天例会，师傅老大说，看我现在手头项目也差不多好了，就说叫我下周开始学习<code>React</code>  + <code>Webpack</code> ，新项目会用到吧，正好我也想研究点新东西加上项目实践。然后ECUI项目边弄吧。</p>
<p>明天团建得早起，2天时间得忙咯，貌似去北京郊外玩玩，顺带爬爬山。好久没去走走了，快枯萎了。晚安。</p>
]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
    
    </summary>
    
      <category term="前端" scheme="https://hyb628.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="https://hyb628.github.io/tags/ES6/"/>
    
      <category term="JSX" scheme="https://hyb628.github.io/tags/JSX/"/>
    
      <category term="React" scheme="https://hyb628.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>古水北镇</title>
    <link href="https://hyb628.github.io/2016/05/18/20160518%E5%8F%A4%E6%B0%B4%E5%8C%97%E9%95%87/"/>
    <id>https://hyb628.github.io/2016/05/18/20160518古水北镇/</id>
    <published>2016-05-18T13:20:21.000Z</published>
    <updated>2017-04-29T13:28:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>快20天没唠叨了，本想今晚睡前说点啥或者写个技术总结啥的，但是无奈快要感冒似的 （估计刚抽完烟自我感觉有关系），下次再说来这里写吧。听首歌再去睡觉。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=35470197&auto=1&height=66"></iframe>

<p>周末部门间要团建，所以到时候估计就有照片又可以更新了，昨天在Mac上面安装AE，打开速度很快的我快眼瞎了，所以就打算周末要是有好的照片啥的或者 周末回来弄个AE 刚好可以试试电脑渲速度。</p>
<p>[2016.5 更新]</p>
<p>古水北镇 &amp; 长城 浪去了~~</p>
<p><img src="/images/20160518/1.jpg" alt=""></p>
<p><img src="/images/20160518/2.jpg" alt=""></p>
<iframe src="http://yuntv.letv.com/bcloud.html?uu=n69ejaickb&amp;vu=e18839e26b&amp;auto_play=0&amp;gpcflag=1&amp;width=640&amp;height=360" width="100%" height="380" frameborder="0" marginwidth="0" marginheight="0"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快20天没唠叨了，本想今晚睡前说点啥或者写个技术总结啥的，但是无奈快要感冒似的 （估计刚抽完烟自我感觉有关系），下次再说来这里写吧。听首歌再去睡觉。&lt;/p&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; margin
    
    </summary>
    
      <category term="生活" scheme="https://hyb628.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="https://hyb628.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="生活" scheme="https://hyb628.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
