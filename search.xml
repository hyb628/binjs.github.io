<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[supervisor自动监测文件修改]]></title>
      <url>%2F2017%2F06%2F23%2Fsupervisor%E7%9B%91%E6%B5%8B%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%2F</url>
      <content type="text"><![CDATA[在node.js中，有时候项目中修改一个配置文件，需要重新npm start , supervisor插件很好的解决了这一难题。 supervisor安装1npm i -g supervisor supervisor参数监控的文件夹或文件，默认为’.’ 1-w | --watch &lt;watchItems&gt; 要忽略监控的文件夹或js文件： 1-i | --ignore &lt;ignoreItems&gt; 监控文件变化的时间间隔（周期），默认为Node.js内置的时间：1-p | --poll-interval &lt;milliseconds&gt; 要执行的主应用程序，默认为’node’： 1-x | --exec &lt;executable&gt; 开启debug模式（用–debug flag来启动node）：1--debug 安静模式，不显示DEBUG信息：1-q |--quiet package.json中使用123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;supervisor server.js&quot;,&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[setState不及时更新的问题]]></title>
      <url>%2F2017%2F06%2F01%2F%E4%B8%BA%E5%95%A5%E8%AF%B4setState%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84%2F</url>
      <content type="text"><![CDATA[老早前在做项目的时候，遇到表单设置select下拉，选择完选项 在其他function函数里面需要拿这个选择的数据，通过 this.state.XXX 去获取，总是拿到一个旧的数据，不会及时的更新，在render里面去拿就能拿到新的数据，当时也没好好去深入，现在做个笔记希望能够思路清晰点。 React官方的文档解释是： Link大致的意思是 setState()不会立刻改变 this.state,而是创建一个即将处理的state。setState()并不一定是同步的，为了提升性能React会批量(也就是合并多次的setState)执行state和DOM渲染。setState()总是会触发一次组件重绘，除非在shouldComponentUpdate()中实现了一些条件渲染逻辑。 123456789101112131415161718var Counter = React.createClass(&#123; getInitialState: function () &#123; return &#123; clickCount: 0 &#125;; &#125;, handleClick: function () &#123; this.setState(&#123; clickCount: this.state.clickCount + 1 &#125;); console.log(this.state.clickCount) // 第一次点击得到 0 &#125;, render: function () &#123; return (&lt;h2 onClick=&#123;this.handleClick&#125;&gt;次数为: &#123;this.state.clickCount&#125;&lt;/h2&gt;); // 第一次点击得到 1 &#125;&#125;);ReactDOM.render( &lt;Counter /&gt;, document.getElementById(&apos;message&apos;)); 再来试试所谓的合并多次state问题，同样的在这个Demo里我handleClick多次setState 看看是什么情况？ 123456789101112131415161718192021var Counter = React.createClass(&#123; getInitialState: function () &#123; return &#123; clickCount: 0 &#125;; &#125;, handleClick: function () &#123; this.setState(&#123; clickCount: this.state.clickCount + 1 &#125;); this.setState(&#123; clickCount: this.state.clickCount + 2 &#125;); console.log(this.state.clickCount) // 依次得到 0, 2, 4 ... &#125;, render: function () &#123; return (&lt;h2 onClick=&#123;this.handleClick&#125;&gt;次数为: &#123;this.state.clickCount&#125;&lt;/h2&gt;); // 依次得到 2, 4, 6 .. &#125;&#125;);ReactDOM.render( &lt;Counter /&gt;, document.getElementById(&apos;message&apos;)); 也就是说 在handleClick执行多次setState , react只会执行最后一次的结果。 如果我用计时器setTimeout 看看会有啥新的发现？ 123456789handleClick: function () &#123; this.setState(function(state) &#123; return &#123;clickCount: state.clickCount + 1&#125;; &#125;); setTimeout(()=&gt;&#123; console.log(this.state.clickCount) // 第一次点击 输出 1 render也同样取到 1 &#125;,100)&#125; 另一个方式则是用componentDidUpdate()这个生命周期方法，把确定state更新后要执行的代码放在里面，如下面的代码: 123456789101112131415161718192021var Counter = React.createClass(&#123; getInitialState: function () &#123; return &#123; clickCount: 0 &#125;; &#125;, handleClick: function () &#123; this.setState(function(state) &#123; return &#123;clickCount: state.clickCount + 1&#125;; &#125;); &#125;, componentDidUpdate()&#123; console.log(this.state.clickCount) // 第一次点击 输出 1 &#125;, render: function () &#123; console.log(&apos;render&apos;); return (&lt;h2 onClick=&#123;this.handleClick&#125;&gt;次数为: &#123;this.state.clickCount&#125;&lt;/h2&gt;); // render也同样取到 1 &#125;&#125;);ReactDOM.render( &lt;Counter /&gt;, document.getElementById(&apos;message&apos;)); react 官方的说明方法提供了callback的回调方式获取最新的state状态 setState(object nextState[, function callback]) nextState，将要设置的新状态，该状态会和当前的state合并 callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。 12345handleClick: function () &#123; this.setState(&#123;clickCount: this.state.clickCount + 1&#125;, function() &#123; console.log(this.state.clickCount) // 依次输出 1, 2, 3 ... &#125;);&#125; [参考]为什么setState没有立即执行为何说setState方法是异步的？解密 setState]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS 反转二叉树]]></title>
      <url>%2F2017%2F06%2F01%2FJS%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
      <content type="text"><![CDATA[面试的时候，问了一个反转二叉树的实现，做个笔记。 123456789101112131415Invert a binary tree. 4 / \ 2 7 / \ / \1 3 6 9to 4 / \ 7 2 / \ / \9 6 3 1 123456789101112var invertTree = function(root) &#123; if(root == null) &#123; // 如果不存在，则返回[] return root; &#125; else &#123; // 交换左右结点 var temp = root.left; root.left = root.right; root.right = temp; &#125; invertTree(root.left); // 转换左子树 invertTree(root.right); // 转换右子树 return root;//返回最后结果&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6的Array.from、Set数组去重]]></title>
      <url>%2F2016%2F09%2F14%2FES6%E7%9A%84Array.from%E3%80%81Set%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
      <content type="text"><![CDATA[Set数据结构ES6中新增了Set数据结构，类似于数组，但是 它的成员都是唯一的 ，其构造函数可以接受一个数组作为参数，如： 1234let array = [1, 1, 1, 1, 2, 3, 4, 4, 5, 3];let set = new Set(array);console.log(set);// =&gt; Set &#123;1, 2, 3, 4, 5&#125; Array.fromES6中Array新增了一个静态方法Array.from，可以把类似数组的对象转换为数组，如通过querySelectAll方法得到HTML DOM Node List，以及ES6中新增的Set和Map等可遍历对象，如： 1234let set = new Set();set.add(1).add(2).add(3);let array = Array.from(set);console.log(array); // [1, 2, 3] 于是，现在我们可以用一行代码实现数组去重了：于是，现在我们可以用一行代码实现数组去重了: 12let array = Array.from(new Set([1, 1, 1, 2, 3, 2, 4]));console.log(array); //[1, 2, 3, 4]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阶段性技术啰嗦（二）]]></title>
      <url>%2F2016%2F09%2F03%2F%E9%98%B6%E6%AE%B5%E6%80%A7%E6%8A%80%E6%9C%AF%E5%95%B0%E5%97%A62%2F</url>
      <content type="text"><![CDATA[记得上次阶段性啰嗦是在5月份，转眼间，就到九月了，时间过的好快，又过得好漫长，两点一线的生活，充实的生活，也懒到了一定的境界，甚是乏累。今天公司网络升级改造，所以早早就回来，就想起写点啥，虽然经验少，肚子里没墨水也想挣扎一番。Let me see ! 说下最近都在忙啥吧：七月份开始一直到现在一直在弄Approve项目，推迟了上线时间，因为尝试用了React新框架，遇到的问题也挺多了，禅道的Bug可真不是一般的多的。所以，一直解决Bug中。负责这个项目的我们三个人就这么Coding。说到底，项目逻辑的复杂度不是一般的复杂。刚毕业那会工作，主要前端开发的一般偏向UI方面，所以，交互，数据方面一般处理的比较少甚至基本都是交于后端处理，这方面比较薄弱，经过以前的面试洗礼，有个面试官说，我们只要做JS交互方面的，才下定决心一定要坚持在这方向努力学习才行。不过，也很感叹，一开始以为切切图的码畜，原来常挂嘴里的切图，自从遇到了公司了一位设计转UI切图的资深女同事才发现，原来切图人家真的到了一定的境界，让我好生佩服。 说说最近的一些问题：刚开始我们老大说项目重构，要用React，所以，很正常，很多人肯定没接触了，都要从0开始，毕竟，在Ag横行的年代，也是还是有一些牛逼的技术栈并行。记得6月份就说要用了，然后自己也看了FB官网的API，东西也不多，但是，React 只是负责V层面上的东西，伴随它有用的东西就一个state和props, 以及一些生命周期，在React中，数据的流向是单向的，基于react + redux的模式开发配合着ES6（ES6很多东西写着确实不错，就那么些，Babel就帮你搞定了，加上Webpack可以把你代码转为兼容低版本的ES3或者是ES5之类的代码）就这么孕育而生。 Redux 官网1231. store 是应用的状态管理中心，保存着是应用的状态（state），当收到状态的更新时，会触发视觉组件进行更新。2. container 是视觉组件的容器，负责把传入的状态变量渲染成视觉组件，在浏览器显示出来。3. reducer 是动作(action)的处理中心， 负责处理各种动作并产生新的状态（state），返回给store。 nvm Github我Mac是直接用了nvm进行node版本的控制，切换node版本的时候 是直接 nvm use 6.2.1 或者是 nvm use 4.4.5 之类的不同版本切换，如果需要用到的情况下。不过也有其他东西类似的版本控制。 ES6历时将近6年的时间来制定的新 ECMAScript 标准 ECMAScript 6（亦称 ECMAScript Harmony，简称 ES6）终于在 2015 年 6 月正式发布。自从上一个标准版本 ES5 在 2009 年发布以后，ES6 就一直以新语法、新特性的优越性吸引著众多 JavaScript 开发者，驱使他们积极尝鲜。 阮一峰的《ECMAScript 6 入门》InfoQ上的 《深入浅出ES6》 一般都是都是看这两个 比较全， 不过一般用到才去看下或者查下，一般常用的就是箭头函数，或者是解构或者是新增加的一些方法，比较方便，比如Object.assign() 项目里也用的比较多， 12Object.assign(target, ...sources)Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。 直接戳MDN 类似的字符串模板也不过 比如：1234const names = `一喵呜`;console.log(`$&#123;names&#125; binjs.com`);result: 一喵呜 binjs.com 12345Spread： export function getSelCCuser(options) &#123; const &#123; approveId, ...others &#125; = options; return httpUtil.post(`/api/approve/w1/approves/$&#123;approveId&#125;/cc`, &#123;...others&#125; );&#125; 12const &#123; detail, name &#125; = this,propsconst &#123; names &#125; = this.state 还有比如，项目遇到一个前端模糊搜索匹配问题，想到正则比较麻烦，还好，想到ES6有includes() 这个东西，一切就好办了。 之类的 等等，还是不错的。 Ant-Design 官网项目UI基于蚂蚁金服的ant进行组件开发，项目里需要用到一个抽屉组件，一开始，真不知道怎么搞，不过，最后不知道怎么纠结，最后，把抽屉小组件写了整合进ant项目里，发布到npm，供以后公司项目其他项目模块重构可以服用，不过蚂蚁金服确实很赞，但是还是也还是遇到很多问题，真的操碎心。 这几天，发现基于React Nactive的mobile ant组件出来了，虽然没用过不过还是很好奇的。Mobile官网 之前Leader说一人写几个组件，然后因为组件要整合的太多，因为React都是很多一个个小组件，UI样式也没，最后就直接用蚂蚁金服这个来复用开发，还有类似的很多 比如： Amaze-UI ， Material-UI，但后面这两个确实不行。哈。 React 组件间的通信，纯粹自己理解就是：121. 父级 --&gt; 子级 ： props2. 子级 --&gt; 父级： callback lodash 官网Approve项目还引入了一个工具库，算是对JS的一个扩充吧。有些API用着还是不错的。 PromisePromise这个水好深，反正现在就是我只知道的理解就是异步的处理 ，then的类似回调。不过看了这篇文章还是太难过了。比较稚嫩 ， 抽根烟先去睡觉。后面好好学习。 再做补充。 保存个书签：Promise迷你书（中文版）[翻译] We have a problem with promises]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[求负数的二进制]]></title>
      <url>%2F2016%2F09%2F03%2F%E8%B4%9F%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%2F</url>
      <content type="text"><![CDATA[[转] 负数用二进制表达。比如，假设有一 int 类型的数，值为5，那么，我们知道它在计算机中表示为：100000000 00000000 00000000 00000101 5转换成二制是101，不过int类型的数占用4字节（32位），所以前面填了一堆0。现在想知道，-5在计算机中如何表示？ 在计算机中，负数以其正值的补码形式表达。 什么叫补码呢？这得从原码，反码说起。 原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。 比如 00000000 00000000 00000000 00000101 是 5的 原码。反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。取反操作指：原为1，得0；原为0，得1。（1变0; 0变1）比如：将00000000 00000000 00000000 00000101每一位取反，得11111111 11111111 11111111 11111010。 称：11111111 11111111 11111111 11111010 是 00000000 00000000 00000000 00000101 的反码。 反码是相互的，所以也可称： 11111111 11111111 11111111 11111010 和 00000000 00000000 00000000 00000101 互为反码。 补码：反码加1称为补码。 也就是说，要得到一个数的补码，先得到反码，然后将反码加上1，所得数称为补码。比如：00000000 00000000 00000000 00000101 的反码是：11111111 11111111 11111111 11111010。那么，补码为： 111111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011 所以，-5 在计算机中表达为：11111111 11111111 11111111 11111011。转换为十六进制：0xFFFFFFFB。再举一例，我们来看整数-1在计算机中如何表示。假设这也是一个int类型，那么： 1231、先取1的原码： 00000000 00000000 00000000 000000012、得反码： 11111111 11111111 11111111 111111103、得补码： 11111111 11111111 11111111 11111111 可见，－1在计算机里用二进制表达就是全1。16进制为：0xFFFFFF]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[随笔 2016-08-6]]></title>
      <url>%2F2016%2F08%2F06%2F20160806%E9%9A%8F%E7%AC%94%2F</url>
      <content type="text"><![CDATA[深夜，又是一个周末，难得这个周末啥都断想，啥都不管，就这么放空。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SASS用法小记]]></title>
      <url>%2F2016%2F06%2F18%2FSASS%E7%94%A8%E6%B3%95%E5%B0%8F%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[之前项目用LESS，现在新项目打算用SASS，所以做个主要常用知识点小记。 在线编译地址@import 引入12 @import &quot;../binjs.scss&quot;; // 引入文件 @import &quot;../huangyb.css&quot;; @mixin 混入 注意：LESS的变量用@ , SASS是 $ 带参数 1234567@mixin borderSet($dott: solid, $color: #fcf) &#123; border: 8px $dott $color;&#125;div &#123; opacity: 0; @include borderSet(dotted, #fa0); //带参数传入&#125; 不带参数 显示默认值 不定义参数值 就显示默认值 1234567@mixin borderSet($dott: solid, $color: #fcf) &#123; border: 8px $dott $color;&#125;div &#123; opacity: 0; @include borderSet; //不带参数传入 可括号 可不括号&#125; 嵌套 LESS也是一样的嵌套规则， &amp; 符号都相同 使用&amp;引用父元素 1234567div &#123; opacity: 0; @include borderSet(); //不带参数传入 可括号 可不括号 &amp;:after &#123; color:#ccc; &#125; &#125; 属性的嵌套 123456 p &#123; border: &#123; color:red; width:12px; &#125;&#125; 变量用 #{} 包裹如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。一般来说，我们设置的变量都是用于属性值的，而如果用在属性或者选择器上，就得以#{}包裹起来了。 123456789$className:huangyb;.#&#123;$className&#125; &#123; width: 12px;&#125;// 解析成.huangyb &#123; width: 12px;&#125; 12345678$side : left;.#&#123;$side&#125; &#123; border-#&#123;$side&#125;-radius: 5px;&#125;// 解析成.left &#123; border-left-radius: 5px;&#125; !default 的使用正常情况下 声明两个变量 会出现后面覆盖前面的变量12345$color:red;$color:blue;p&#123; color:$color; //blue&#125; 若声明了 !default 会就不能出现覆盖的现象 12345$color:red;$color:blue !default;p&#123; color:$color; //red&#125; 多个变量的声明12345678910111213141516$linkColor: red blue;a&#123; color:nth($linkColor,1); &amp;:hover&#123; color:nth($linkColor,2); &#125;&#125;// 解析后a &#123; color: red;&#125;a:hover &#123; color: blue;&#125; @extend 继承1234567891011121314151617181920div &#123; color:#fcf; &#125;p &#123; @extend div; width:10px; &#125;span &#123; @extend p;&#125;// 解析后div, p, span &#123; color: #fcf;&#125;p, span &#123; width: 10px;&#125; function123456789101112@function binjs($value) &#123; @return #&#123;$value&#125;px;&#125;div &#123; width: binjs(30);&#125;//解析后div &#123; width: 30px;&#125; @if @else 条件判断12345678$width:12px;div &#123; @if ($width&gt;10) &#123; color:#fcf; &#125; @else &#123; color:#fa0;; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6数组的扩展]]></title>
      <url>%2F2016%2F06%2F13%2FES6%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
      <content type="text"><![CDATA[今天培训了,只能自己看这些东西啦。一天时间又过去了。现在文章，或者我的印象笔记都是采用Markdown 来写了， 是不是看起来比较整洁了。有点想改用Hexo, 看着很不错，markdown 也写得比较有意思 貌似。 一直想弄 ，但是又怕麻烦。 Array.from1234567891011121314let arrayLike = &#123; &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]等同于：var arr1 = Array.prototype.slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]// ES6的写法let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 查看之前文章Array.prototype.slice.call介绍 不过，对象数组的写法需要严格按照规范写，比如：1234var foo = &#123;0:&apos;hello&apos;,1:&apos;world&apos;,length:4&#125;;Array.prototype.slice.call(foo); // [&quot;hello&quot;, &quot;world&quot;, undefined × 2]Array.from(arrayLike); // [&quot;hello&quot;, &quot;world&quot;, undefined, undefined] Array.from() 的第一个参数决定第二个参数的执行次数， 12Array.from(&#123; length: 3 &#125;); // [undefined, undefined, undefinded]Array.from(&#123;length:3&#125;,() =&gt;&apos;binjs&apos;); // [&apos;binjs&apos;, &apos;binjs&apos;, &apos;binjs&apos;] Array.from() 还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] 只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。1234Array.from(&apos;hello&apos;); // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]let namesSet = new Set([&apos;a&apos;, &apos;b&apos;]);Array.from(namesSet); // [&apos;a&apos;, &apos;b&apos;] Array.of方法用于将一组值，转换为数组。 1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] includes与字符串的includes方法类似1[1,2,3].includes(1); // true ind() 和 findIndex()find() 返回数组中满足测试条件的一个元素，如果没有满足条件的元素，则返回 undefined。 1[1, 4, -5, 10].find((n) =&gt; n &lt; 0) find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 12345[1, 3, 5].find(function(value, index, arr) &#123; console.log(value); console.log(index); console.log(arr); &#125;) findIndex() 用来查找指定的索引，如果找不到指定的元素, 则返回 -1 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 fill()fill() 用来进行数组的填充 ，第二和第三个参数表示开始和结束位置 12[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 0, 1) //[7, &quot;b&quot;, &quot;c&quot;][&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 0, 2) // [7, 7, &quot;c&quot;] fill() 可以用来初始化一个数组 12345[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6数值的扩展]]></title>
      <url>%2F2016%2F06%2F12%2FES6%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
      <content type="text"><![CDATA[数值的扩展ES6提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 120b111110111 === 503 // true0o767 === 503 // true 转为十进制的方法 使用Number： 12Number(&apos;0b111&apos;) // 7Number(&apos;0o10&apos;) // 8 Number.isFinite()用来检测传入的参数是否是一个有穷数。和全局的 isFinite() 函数相比，这个方法不会强制将一个非数字的参数转换成数字，这就意味着，只有真正的数字才有可能返回 true。 1234567891011Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite(&apos;foo&apos;); // falseNumber.isFinite(&apos;15&apos;); // falseNumber.isFinite(true); // falseNumber.isFinite(0); // trueNumber.isFinite(2e64); // trueNumber.isFinite(&apos;0&apos;); // false, 全局函数 isFinite(&apos;0&apos;) 会返回 true Number.isNaN()用来检查一个值是否为NaN。 这两个新方法只对数值有效，非数值一律返回false。 123456789isFinite(25) // trueisFinite(&quot;25&quot;) // trueNumber.isFinite(25) // trueNumber.isFinite(&quot;25&quot;) // falseisNaN(NaN) // trueisNaN(&quot;NaN&quot;) // trueNumber.isNaN(NaN) // trueNumber.isNaN(&quot;NaN&quot;) // false Number.parseInt(), Number.parseFloat()ES6 将全局的parseInt 和 parseFloat移植到Number对象上 Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3 与 3.0 || 3.00 被视为同一个值。 12345Number.isInteger(25) // trueNumber.isInteger(25.0) // trueNumber.isInteger(25.1) // falseNumber.isInteger(&quot;15&quot;) // falseNumber.isInteger(true) // false Number.EPSILON 常量ES6在Number对象上面，新增一个极小的常量Number.EPSILON。 引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。 123456780.1 + 0.2// 0.300000000000000040.1 + 0.2 - 0.3// 5.551115123125783e-175.551115123125783e-17.toFixed(20)// &apos;0.00000000000000005551&apos; 但是如果这个误差能够小于Number.EPSILON，我们就可以认为得到了正确结果。 15.551115123125783e-17 &lt; Number.EPSILON // true Math对象的扩展Math.trunc()用于去除一个数的小数部分，返回整数部分 123456Math.trunc(4.1) // 4Math.trunc(4.9) // 4Math.trunc(-4.1) // -4Math.trunc(-4.9) // -4Math.trunc(-0.1234) // -0Math.trunc(&apos;123.456&apos;) // 123 对于空值和无法截取整数的值，返回NaN。 1234Math.trunc(NaN); // NaNMath.trunc(&apos;foo&apos;); // NaNMath.trunc(); // NaNMath.trunc(&apos;123a.456&apos;) // NaN Math.sign()用来判断一个数到底是正数、负数、还是零。 参数为正数，返回+1；参数为负数，返回-1；参数为0，返回0；参数为-0，返回-0;其他值，返回NaN。 1234567Math.sign(-5) // -1Math.sign(5) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(NaN) // NaNMath.sign(&apos;foo&apos;); // NaNMath.sign(); // NaN]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6解构赋值]]></title>
      <url>%2F2016%2F06%2F11%2FES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
      <content type="text"><![CDATA[配置文件.babelrcBabel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。 ES草案阶段 Stage 0 - Strawman（展示阶段） Stage 1 - Proposal（征求意见阶段） Stage 2 - Draft（草案阶段） Stage 3 - Candidate（候选人阶段） Stage 4 - Finished（定案阶段） let和const 命令let不像var那样会发生“变量提升”现象（就是var 定义了 然后输出undefined，let 直接报错 ）。所以，变量一定要在声明后使用，否则报错。 ES6的块级作用域let实际上为JavaScript新增了块级作用域。 块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。1234567891011// IIFE写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 下面的代码如果使用var 输出的是 101234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123;a[i] = function () &#123; console.log(i);&#125;;&#125;a[6](); // 6 不存在变量提let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。 变量不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 解构赋值直接赋值1var [a, b, c] = [1, 2, 3]; Set 赋值1let [x, y, z] = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]); 默认值如果一个数组成员不严格等于undefined，默认值是不会生效的。12let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined];console.log(x,y) 如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。12345var [x = 1] = [undefined];x // 1var [x = 1] = [null];x // null 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 对象的解构赋值1var &#123; foo: foo, bar: bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;; 对象的解构也可以指定默认值。123456789var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123; message: msg = &quot;Something went wrong&quot; &#125; = &#123;&#125;;msg // &quot;Something went wrong&quot; 现有对象方法赋值到某个变量 1let &#123; log, sin, cos &#125; = Math; 解析出来的结果类似 代码1234&quot;use strict&quot;;var log = Math.log;var sin = Math.sin;var cos = Math.cos; 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。123456const [a, b, c, d, e] = &apos;hello&apos;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot; 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 12let &#123;length : len&#125; = &apos;hello&apos;;len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 函数参数的解构赋值1234function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 解构赋值用途交换变量的值1[x, y] = [y, x]; 从函数返回多个值1234567891011121314// 返回一个数组function example() &#123; return [1, 2, 3];&#125;var [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;var &#123; foo, bar &#125; = example(); 函数参数的定义1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据12345678910var jsonData = &#123;id: 42,status: &quot;OK&quot;,data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309] 遍历Map结构123456789var map = new Map();map.set(&apos;first&apos;, &apos;hello&apos;);map.set(&apos;second&apos;, &apos;world&apos;);for (let [key, value] of map) &#123;console.log(key + &quot; is &quot; + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 123456789// 获取键名for (let [key] of map) &#123;// ...&#125;// 获取键值for (let [,value] of map) &#123;// ...&#125; 字符串的扩展传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。 includes()返回布尔值，表示是否找到了参数字符串。 12345var s = &apos;Hello world!&apos;;if(s.includes(&apos;ld&apos;)) &#123; console.log(1)&#125; startsWith()返回布尔值，表示参数字符串是否在源字符串的头部。 1s.endsWith(&apos;!&apos;) // true endsWith()返回布尔值，表示参数字符串是否在源字符串的尾部。 1s.endsWith(&apos;!&apos;) // true 这三个方法都支持第二个参数，表示开始搜索的位置。 12345const s = &apos;Hello world!&apos;;s.startsWith(&apos;world&apos;, 6) // trues.endsWith(&apos;Hello&apos;, 5); // trues.endsWith(&apos;Hell&apos;, 4); // trues.includes(&apos;Hello&apos;, 6) // false 字符串模板123// 字符串中嵌入变量let name = &quot;Bob&quot;, time = &quot;today&quot;;console.log(`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`) 模板字符串都是用 `, 也可以用来调用函数 1234function add() &#123; console.log(1222);&#125;let str = `Nihai $&#123;add()&#125;`;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BFC的理解与应用]]></title>
      <url>%2F2016%2F06%2F06%2FBFC%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[题记：在 CSS 面试中问 BFC 等概念，就如在 JS 面试中问闭包等概念一样，经常会刷掉一些真正优秀的人。 ——玉伯今天突然想起之前找工作，李鹏大哥的一个面试题，问我什么是「BFC」，一脸茫然，这么专业的词语还真没听过？不过，今天顺便自己理解这个东西，免得强迫症又犯了。下面的全文部分载自 W3cplus，总结的很好很详细，自己文章写了一点就不想写了，就直接转过来了。首先我们来看看w3c规范对BFC的解释，其实对于这种概念的学习上，我们总是建议首先寻找官方的定义，因为原则上来说官方的才是最权威和正确的，而且还比较详细，千万不要因为看到英文就畏惧不前。什么是BFC（Block formatting contexts）w3c规范中的BFC定义：浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。BFC的通俗理解：首先BFC是一个名词，是一个独立的布局环境，我们可以理解为一个箱子（实际上是看不见摸不着的），箱子里面物品的摆放是不受外界的影响的。转换为BFC的理解则是：BFC中的元素的布局是不受外界的影响（我们往往利用这个特性来消除浮动元素对其非浮动的兄弟元素和其子元素带来的影响。）并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。BFC的运用在w3c的规范中，除了上面的一段定义之外，BFC的相关知识点分布地比较零散，但基本集中在float、绝对定位、margin collaspe中。下面我们来看看如何应用到BFC来解决问题。在很多网站中，我们经常会看到这样的一种，左边图片+右边信息的两栏结构，下面我们来看看如何利用BFC来实现。首先我们给出这样的结构：//CSS.box {width:210px;border: 1px solid #000;float: left;}.img {width: 100px;height: 100px;background: #696;float: left;}.info {background: #ccc;color: #fff;}//HTML&lt;div class=“box”&gt; &lt;div class=“img”&gt;image&lt;/div&gt; &lt;p class=“info”&gt;信息信息信息信息信息信息信息信息信息信息信息信&lt;/p&gt;&lt;/div&gt;一般情况下它呈现出我们所乐意看到的样子：但随着文字信息增多后，会变地非常的糟糕：很明显，这是因为info类里面的文字受到了浮动元素的影响，但这并不是我们所期望的。此时我们可以为P元素的内容建立一个BFC，让其内容消除对外界浮动元素的影响。根据上文所知，只要给info元素添加overflow:hidden;即可为其内容建立新的BFC。当然你也可以通过其他方法来建立。其效果如下：合并外边距与BFC在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。折叠的结果： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。产生折叠的必备条件：margin必须是邻接的!而根据w3c规范，两个margin是邻接的必须满足以下条件： 必须是处于常规文档流（非float和绝对定位）的块级盒子,并且处于同一个BFC当中。 没有线盒，没有空隙（clearance，下面会讲到），没有padding和border将他们分隔开 都属于垂直方向上相邻的外边距，可以是下面任意一种情况 元素的margin-top与其第一个常规文档流的子元素的margin-top 元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom 高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottom以上的条件意味着下列的规则： 创建了新的BFC的元素（例如浮动元素或者’overflow’值为’visible’以外的元素）与它的子元素的外边距不会折叠 浮动元素不与任何元素的外边距产生折叠（包括其父元素和子元素） 绝对定位元素不与任何元素的外边距产生折叠 inline-block元素不与任何元素的外边距产生折叠 一个常规文档流元素的margin-bottom与它下一个常规文档流的兄弟元素的margin-top会产生折叠，除非它们之间存在间隙（clearance）。 一个常规文档流元素的margin-top 与其第一个常规文档流的子元素的margin-top产生折叠，条件为父元素不包含 padding 和 border ，子元素不包含 clearance。 一个 ‘height’ 为 ‘auto’ 并且 ‘min-height’ 为 ‘0’的常规文档流元素的 margin-bottom 会与其最后一个常规文档流子元素的 margin-bottom 折叠，条件为父元素不包含 padding 和 border ，子元素的 margin-bottom 不与包含 clearance 的 margin-top 折叠。 一个不包含border-top、border-bottom、padding-top、padding-bottom的常规文档流元素，并且其 ‘height’ 为 0 或 ‘auto’， ‘min-height’ 为 ‘0’，其里面也不包含行盒(line box)，其自身的 margin-top 和 margin-bottom 会折叠。（下面我们对不产生折叠的情况逐一分析。）浮动和绝对定位不与任何元素产生 margin 折叠原因：浮动元素和绝对定位元素不与其他盒子产生外边距折叠是因为元素会脱离当前的文档流，违反了上面所述的两个margin是邻接的条件同时，又因为浮动和绝对定位会使元素为它的内容创建新的BFC，因此该元素和子元素所处的BFC是不相同的，因此也不会产生margin的折叠。DEMO：//CSSbody {padding:0;margin: 0; text-align: center;}.wrapper {margin:30px;width: 450px;border:1px solid red;}.small-box {width: 50px;height: 50px;margin: 10px;background: #9cc;}.middle-box {width: 100px;height: 100px;margin: 20px;background: #99c;}.big-box {width: 120px;height: 120px;margin: 20px;background: #33e;}.floatL {float: left;}.floatR {float: right;}.clear {clear: both;}.posA {position: absolute;}.overHid{overflow: hidden;}.red {background: #f00;}.green {background: #0f0;}.blue {background: #00f;}//HTML&lt;div class=“wrapper overHid”&gt; &lt;div class=“big-box blue”&gt;non-float&lt;/div&gt; &lt;div class=“middle-box green floatL”&gt; &lt;div class=“small-box red”&gt;&lt;/div&gt; float left &lt;/div&gt;&lt;/div&gt;但是浮动元素脱离了当前的BFC并不影响它后面的兄弟元素，后面的兄弟元素与浮动元素前面的元素依然在同一个BFC当中，所以，它们之间的margin还是会折叠的。下面我们对上面的demo做一下修改：&lt;div class=“wrapper overHid”&gt; &lt;div class=“big-box”&gt;non-float&lt;/div&gt; &lt;div class=“middle-box green floatL”&gt;float left&lt;/div&gt; &lt;div class=“middle-box red”&gt;non-clear&lt;/div&gt;&lt;/div&gt;从上面这个修改后的demo中可以看出，红色的块盒在没有清楚浮动的情况下，它的margin-top和蓝色块盒的margin-bottom产生了折叠，这证明了我上面的结论。下面我们来谈谈 ‘clearance’ 这个神奇的东西，当浮动元素之后的元素设置clear以闭合相关方向的浮动时，根据w3c规范规定，闭合浮动的元素会在其margin-top以上产生一定的空隙（clearance，如下图），该空隙会阻止元素margin-top的折叠，并作为间距存在于元素的margin-top的上方。关于这个间距的计算稍微有点复杂，但实际工作中你并不需要去计算它，我们先来看看例子吧：&lt;div class=“wrapper overHid”&gt; &lt;div class=“big-box” style=“box-shadow:0 20px 0 rgba(0,0,255,0.2);”&gt;non-float&lt;/div&gt; &lt;div class=“middle-box green floatL” style=“opacity:0.6”&gt;float left&lt;/div&gt; &lt;div class=“middle-box red clear” style=“margin-top:40px;box-shadow:0 -40px 0 rgba(255,0,0,0.2);”&gt;clear&lt;/div&gt;&lt;/div&gt;上面的图中我们可以看到，我们为红色块盒设置的40px的margin-top（这里我们通过相同高度的阴影来将其可视化）好像并没有对紫色块盒起作用，而且无论我们怎么修改这个margin-top值都不会影响红色块盒的位置，而只由绿色块盒的margin-bottom所决定。也就是说，我们只需要知道，闭合浮动的元素的border-top会紧贴着相应的浮动元素的margin-bottom。原来，通过w3c的官方规范可知，闭合浮动的块盒在margin-top上所产生的间距（clearance）的值与该块盒的margin-top之和应该足够让该块盒垂直的跨越浮动元素的margin-bottom，使闭合浮动的块盒的border-top恰好与浮动元素的块盒的margin-bottom相邻接。用上图例子中的相关值可以得出这样一个式子：r-margin-top + r-clearance = g-margin-top + g-height + g-margin-bottomPS！闭合浮动并不能使浮动元素回到原来的BFC当中！分析二：inline-block元素与其兄弟元素、子元素和父元素的外边距都不会折叠（包括其父元素和子元素）inline-block不符合w3c规范所说元素必须是块级盒子的条件，因为规范中又说明，块级盒子的display属性必须是以下三种之一：’block’， ‘list-item’， 和 ‘table’。参考资料 http://www.w3.org/TR/CSS2/box.html http://www.w3.org/TR/CSS2/visuren.html#block-formatting http://www.w3.org/TR/CSS2/box.html#collapsing-margins「出处」这篇文章也总结的还不错 做个引用 http://www.ido321.com/1642.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React学习笔记2]]></title>
      <url>%2F2016%2F05%2F31%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%2F</url>
      <content type="text"><![CDATA[React学习笔记（一） 主要学习顶层API的东西，这里主要学习组件的生命周期东西，在这里做些笔记，免得自己健忘。ReactDOM 提供了卸载组件的API，ReactDOM.unmountComponentAtNode 进行组件的移除或者卸载。 StackOverflow 问答： http://dwz.cn/3tx3gJ 1234567891011var SampleComponent = React.createClass(&#123; render: function() &#123; return &lt;div&gt;Mounted component.&lt;/div&gt;; &#125;&#125;);ReactDOM.render(&lt;SampleComponent /&gt;, document.getElementById(&apos;container&apos;));setTimeout(function() &#123; ReactDOM.unmountComponentAtNode(document.getElementById(&apos;container&apos;));&#125;, 3000); 有一点需要注意的是：React组件被卸载的时候，会触发componentWillUnmount，具体可以可以看下实例： 12345678910111213141516171819202122232425262728293031var p = 0, timer;var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;一喵呜 &#123;this.props.name&#125;&lt;/h1&gt;; &#125;, componentWillMount: function () &#123; console.log(&apos;componentWillMount&apos;); &#125;, getInitialState: function () &#123; timer = setInterval(function () &#123; p++; console.log(p); if (p === 3) &#123; ReactDOM.unmountComponentAtNode(document.getElementById(&apos;example4&apos;) ); &#125; &#125;,1000); console.log(&apos;getInitialState&apos;); &#125;, componentDidMount: function () &#123; console.log(&apos;componentDidMount&apos;); &#125;, componentWillUnmount: function() &#123; clearInterval(timer); console.log(&apos;卸载执行,清除计数器成功&apos;); &#125;&#125;);ReactDOM.render( &lt;HelloMessage name=&quot;BinJS&quot;/&gt;, document.getElementById(&apos;example4&apos;)); 查找组件react可以允许我们通过 ref 来定位一个组件。所以可以这样：先给一个组件设置一个 ref=‘xxx’ 的属性，注意这个ref必须是全局唯一的。 然后就可以通过 this.refs.city 来访问这个组件。但是获取到的组件是一个虚拟的DOM，因此才有了用ReactDOM.fineDOMNode 来获取一个真实的DOM节点，需要注意的是获取真实DOM需要在render之后才能获取成功，如果之前或者是没有这个DOM就返回 null 移动端触摸事件 v0.15版本之前开启移动端触摸事件需要这样：进行移动开发时，渲染之前需要先调用React.initializeTouchEvents(true)，然后使用onTouchCancel onTouchEnd onTouchMove onTouchStart来进行触摸事件的开发 v0.15 最新版本移除了这样的调用，直接用移动端事件就能用了： 1onTouchCancel onTouchEnd onTouchMove onTouchStart 非DOM 属性 key 表单组件 123456789// 文本框默认 &apos;hi&apos; 可以输入ReactDOM.render(&lt;input defaultValue=&quot;hi&quot; /&gt;, mountNode); // 文本框为空 可以输入ReactDOM.render(&lt;input value=&#123;undefined&#125; /&gt;, mountNode); ReactDOM.render(&lt;input /&gt;, mountNode); // 文本框默认 &apos;hi&apos; 只读状态 不能输入ReactDOM.render(&lt;input value=&apos;hi&apos;/&gt;, mountNode); 设置了 value 的 &lt;input&gt;是一个受限组件。 对于受限的 &lt;input&gt;，渲染出来的 HTML 元素始终保持 value 属性的值。 通过设置value为 null 或undefined或 通过设置一个ref属性，然后this.refs 获取到虚拟DOM进行修改value 或者是event.target.value 同样地， 类型为 radio、checkbox 的&lt;input&gt;支持 defaultChecked 属性， &lt;select&gt;支持defaultValue 属性。 受限组件1234567891011121314151617181920212223var InputChangeValue = React.createClass(&#123; getInitialState: function () &#123; return &#123;value: &apos;binjs&apos;&#125;; &#125;, handleChange: function (event) &#123; console.log(event.target.value); this.setState(&#123;value: event.target.value&#125;); //this.setState(&#123;value: event.target.value.substr(0, 140)&#125;); // 限制140个字 &#125;, render: function () &#123; var value = this.state.value; return( &lt;div&gt; &lt;input value=&#123;value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;/div&gt; ) &#125; &#125;) ReactDOM.render( &lt;InputChangeValue /&gt;, document.getElementById(&apos;example5&apos;) ) 不受限组件没有设置 value的 (0.15版本之前 也可以设置null 就是不受限组件) &lt;input&gt;组件是一个不受限组件。对于不受限的 &lt;input&gt;组件，渲染出来的元素直接反应用户输入。 select 表单默认选项 123456789101112131415161718// 单选 默认选中B 可编辑 &lt;select defaultValue=&quot;B&quot;&gt; &lt;option value=&quot;A&quot;&gt;binjs&lt;/option&gt; &lt;option value=&quot;B&quot;&gt;huangyb&lt;/option&gt; &lt;/select&gt; // 单选 默认选中B 不可编辑 &lt;select value=&quot;B&quot;&gt; &lt;option value=&quot;A&quot;&gt;binjs&lt;/option&gt; &lt;option value=&quot;B&quot;&gt;huangyb&lt;/option&gt; &lt;/select&gt;// 设置多选 默认选中B C 可编辑&lt;select multiple=&#123;true&#125; defaultValue=&#123;[&apos;B&apos;, &apos;C&apos;]&#125;&gt; &lt;option value=&quot;A&quot;&gt;binjs&lt;/option&gt; &lt;option value=&quot;B&quot;&gt;huangyb&lt;/option&gt; &lt;option value=&quot;C&quot;&gt;huang&lt;/option&gt;&lt;/select&gt; 通过 AJAX 加载初始数据在 componentDidMount 时加载数据。当加载成功，将数据存储在 state 中，触发 render 来更新你的 UI。当执行异步请求的响应时，在更新 state 前， 一定要先通过 this.isMounted()来检测组件的状态是否还是 mounted。React initial-ajax doc]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React学习笔记1]]></title>
      <url>%2F2016%2F05%2F27%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
      <content type="text"><![CDATA[打算对React的学习过程 分阶段性的学习和总结吧，先把这周主要看的学的知识点做个记录，后期慢慢学到新的东西慢慢整理起来。刚开始比较生疏，难免有问题。 ReactDOM.renderReactDOM.render 里面 逗号分隔 最后面不要不要标点符号 ,ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点. 1ReactDOM.render(element, container, callback) // 回调函数，可选。传入该值时，会在组件渲染完或更新完成后调用 1234ReactDOM.render( &lt;h1&gt;huangyb&lt;/h1&gt;, document.getElementById(&apos;example&apos;)) chrome 扩展程序 扩展程序React Developer Tools react-detector React版本说明写react 需要引入三个JS文件 react.js 、 eacr-dom.js 、 browser.min.js （0.14版本之前合并为一个文件，0.14版本以上就拆分为三个文件） React CDN: http://cdn.bootcss.com/react/15.1.0/react.min.js http://cdn.bootcss.com/react/15.1.0/react-dom.js https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js 页面中用 &lt;script type=&quot;text/babel&quot;&gt;标记来使用 JSX 转换器.在以前旧版本的只有一个react.js 文件 所以假如 React.render 相当于现在新版本的 ReactDOM.render 1ReactDOM.render(&lt;div&gt;&#123;name&#125;&lt;/div&gt; ,document.getElementById(&apos;id&apos;)) 需要有个Root父级元素包裹，不能插入的数据是多个同级，不然会报错。 render的两种方式 JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。 12345var name2 = [&apos;y1&apos;,&apos;y2&apos;,&apos;y3&apos;];ReactDOM.render( &lt;div&gt; &#123; name2.map(function (key) &#123; return &lt;li&gt;&#123;key&#125;&lt;/li&gt; &#125;) &#125; &lt;/div&gt;, document.getElementById(&apos;name22&apos;) ) JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员 12345678var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;];ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById(&apos;example&apos;)); JSX = JavaScriptXML React.createClassReact 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。React.createClass 方法就用于生成一个组件类 1234567891011121314&lt;div id=&quot;con&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt; var HelloMess = React.createClass(&#123; render: function () &#123; return &lt;p className=&quot;pp&quot;&gt;huangyb &#123;this.props.yb&#125;&lt;/p&gt; &#125; &#125;) ReactDOM.render( &lt;HelloMess yb=&quot;你好&quot;&gt;&lt;/HelloMess&gt;, document.getElementById(&apos;con&apos;),function () &#123; console.log(&apos;render完成&apos;); &#125; ) HTML 标签 vs. React 组件 React.render方法可以渲染HTML结构，也可以渲染React组件。渲染HTML标签，声明变量采用首字母小写 12var myDivElement = &lt;div className=&quot;foo&quot; /&gt;;React.render(myDivElement, document.body); 渲染React组件，声明变量采用首字母大写 123var MyComponent = React.createClass(&#123;/*...*/&#125;);var myElement = &lt;MyComponent someProperty=&#123;true&#125; /&gt;;React.render(myElement, document.body); HTML转义123456789var htmlEle = &quot;&lt;strong&gt;htmlEle&lt;/strong&gt;&quot;;ReactDOM.render( &lt;HybNode&gt; &lt;div&gt;HTML转义情况::&#123;htmlEle&#125;&lt;/div&gt; &lt;div dangerouslySetInnerHTML=&#123;&#123;__html: htmlEle&#125;&#125; data-hyb=&quot;xxx&quot; aria-ybs=&quot;true&quot;/&gt; &lt;/HybNode&gt;, document.getElementById(&apos;example3&apos;)) className 和 htmFor 的使用1234567891011#使用JSXReactDOM.render( &lt;label className=&quot;xxx&quot; htmlFor=&quot;input&quot;&gt;content&lt;/label&gt;, document.getElementById(&apos;example&apos;));#不使用JSXReactDOM.render( React.createElement(&apos;label&apos;, &#123;className: &apos;xxx&apos;, htmlFor: &apos;input&apos;&#125;, &apos;content&apos;), document.getElementById(&apos;example&apos;)); js表达式 表达式用{}包起来，不要加引号，加引号就会被当成字符串。 JSX是HTML和JavaScript混写的语法，当遇到&lt;，JSX就当HTML解析，遇到{就当JavaScript解析。 属性表达式:1234ReactDOM.render( &lt;div className=&#123;2 &gt; 1 ? &apos;class-a&apos; : &apos;class-b&apos;&#125;&gt;content&lt;/div&gt;, document.body ); 子表达式: 1234567891011var Nav = React.createClass(&#123; render: function () &#123; return &lt;div&gt;nav&lt;/div&gt; &#125;&#125;);ReactDOM.render( &lt;div&gt; &#123;2 &gt; 1 ? &lt;Nav/&gt; : &lt;div&gt;div&lt;/div&gt;&#125; &lt;/div&gt;, document.body); 注释, 同JS注释一样： 单行： // 多行： /**/ JSX延伸属性为了解决手动添加属性造成的类型错误，React设定初始化完props后，props是不可改变的。为了解决这个问题，React引入了属性延伸。 1234var props = &#123;&#125;;props.foo = x;props.bar = y;var component = &lt;Component &#123;...props&#125; /&gt;; 当需要拓展我们的属性的时候，定义一个属性对象，并通过{…props}的方式引入，React会帮我们拷贝到组件的props属性中。重要的是—这个过程是由React操控的，不是手动添赋值的属性。需要覆盖的时候可以这样写： 123456789101112131415161718192021222324var defaultStyle = &#123; // 这两种方法写样式都能显示 ，但是还是用小驼峰的写法推荐 &apos;font-size&apos;:&apos;20px&apos;, &apos;listStyleType&apos;:&apos;none&apos;&#125;var NodeList = React.createClass(&#123; render: function()&#123; return( &lt;ol&gt; &#123; React.Children.map(this.props.children, function(child)&#123; return &lt;li style=&#123;defaultStyle&#125;&gt;&#123;child&#125;&lt;/li&gt; &#125;) &#125; &lt;/ol&gt; ); &#125;&#125;);ReactDOM.render( &lt;NodeList&gt; &lt;span&gt;23&lt;/span&gt; &lt;span&gt;88&lt;/span&gt; &lt;/NodeList&gt;, document.getElementById(&apos;example2&apos;)) style属性在React中写行内样式时，要这样写，不能采用引号的书写方式 123456ReactDOM.render( &lt;div style=&#123;&#123;color:&apos;red&apos;&#125;&#125;&gt; xxxxx &lt;/div&gt;, document.body); 自定义HTML属性 data-* 、aria-* 如果在编写React过程中往原生HTML标签中使用了自定义属性，React不会渲染的【然而任意属性支持自定义元素 】 1234ReactDOM.render( &lt;div data-dd=&apos;xxx&apos; aria-dd=&apos;xxx&apos;&gt;content&lt;/div&gt;, document.body);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS Hack、JS userAgent]]></title>
      <url>%2F2016%2F05%2F25%2Fcsshack-jsagent%2F</url>
      <content type="text"><![CDATA[摘要：项目中刚好遇到一个样式问题，win10版本的IE11、Edge跟我win8系统IE11浏览器出现了不同程度的样式差异，假如有一像素偏差吧。实在是没辙了，想单纯用CSS去解决，在不动用JS情况下，找了好久的资料，试了几次，发现国外一个大牛写的不错。就整理下。 HACK： browserhacks browserstrangeness 具体内容自己看比较省事，遇到问题有针对性的去解决。 不过，一开始找到的解决我的问题，在stackoverflow上针对CSS hack的回答一个个找好心累，试了又不一定成功，所以就这么搞了，最终找到一个合适的，没办法，业务的东西，只能用hack。 面整理一个侦测IE的Javascript，目前最高支援到IE12。 123456789101112131415161718192021function isIEVersion() &#123; var ua = window.navigator.userAgent; var msie = ua.indexOf(&apos;MSIE &apos;); if (msie &gt; 0) &#123; // 回傳版本 &lt;=10 的版本 return parseInt(ua.substring(msie + 5, ua.indexOf(&apos;.&apos;, msie)), 10); &#125; var trident = ua.indexOf(&apos;Trident/&apos;); if (trident &gt; 0) &#123; // 回傳版本 &gt;=11 的版本 var rv = ua.indexOf(&apos;rv:&apos;); return parseInt(ua.substring(rv + 3, ua.indexOf(&apos;.&apos;, rv)), 10); &#125; var edge = ua.indexOf(&apos;Edge/&apos;); if (edge &gt; 0) &#123; // 判斷Edge return parseInt(ua.substring(edge + 5, ua.indexOf(&apos;.&apos;, edge)), 10); &#125; // other browser return false;&#125; 2016.5.27 更新 1234567.ui-select-options &#123; min-width: 85px\0;&#125; /*9-11*/ _::selection, .ui-select-options &#123; min-width: auto\0; &#125; 处理完后，遇到IE8的下拉问题，接着遇到IE8刷新报错的问题，这个真叫棘手问题。测试开发环境是打包的代码，所有很难找到具体什么原因，只提示一个ECUI.js undefined问题，无奈把测试环境的打包代码都干掉 ，部署本地未打包的源码上去 一个个功能模块去测试，最后，发现是日期组件的问题。只能联系成都的小伙伴看看，叫写组件的看看，确实不是我这边代码问题后，只能修改ECUI.js 做容错处理。 OK，大神就是大神，确定问题后，只能打包构建提测吧，每次总觉得 一到晚上 测试总会给我来个Bug，让我都担心受怕的。这都周五了，我想静静！还指望周末打个球。 早上在修改测试环境的时候，准备把一个文件夹下面的所有文件移到上级目录的时候，因为键盘数字键盘关了，导致 mv * ../ 变成了 mv * /， My Gold，都跑到根目录下了。无奈只能一个个删除咯。 safari浏览器判断: 123if (navigator.userAgent.indexOf(&apos;Mac OS X&apos;) &gt; 0 &amp;&amp; navigator.userAgent.indexOf(&apos;Safari&apos;) &gt; -1 &amp;&amp; navigator.userAgent.indexOf(&apos;Chrome&apos;) &lt; 0) &#123; // code&#125; 不判断Chrome的话会跟Mac下安装的Chrome 和 QQ浏览器混淆，因为在Mac下QQ浏览器返回userAgent： 1&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.82 Safari/537.36 QQBrowser/4.0.4035.400&quot; Chrome在Mac返回的userAgent信息是：1&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36&quot; FireFox在Mac下返回的userAgent信息是：1&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:45.0) Gecko/20100101 Firefox/45.0&quot; Opera在Mac下返回的userAgent信息是：1&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36 OPR/36.0.2130.65&quot; 所以判断有没有Chrome这个关键字就能判断是不是Mac下Safari了。 2016.5.27 pm 更新 发现测试人员用了一个软件挺有意思的，SwitchHost 推荐一下。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阶段性技术啰嗦（一）]]></title>
      <url>%2F2016%2F05%2F20%2F%E9%98%B6%E6%AE%B5%E6%80%A7%E6%8A%80%E6%9C%AF%E5%95%B0%E5%97%A61%2F</url>
      <content type="text"><![CDATA[听听有情怀的歌，陶冶情操！大学很爱的一首歌。 又到周五了，趁现在下班时间，抽空写写最近在公司遇到的坑以及学到的东西吧，最近一直很少做自己的技术总结，老是写生活随笔啥的似乎也不符合我这个愤青的年龄 。看到我都觉得我活在小康社会似的，我都快不相信自己了。 最近一直在做支付项目，公司用到了百度ECUI的一个MVC框架，配合ETpl模板引擎，后台是Java语言，开始做前后端分离 毕竟第一次做，难免有些紧张。(~.~)，讲讲几个遇到的问题以及解决办法吧，俗话说，找到合适的途径 合适的方法才是做重要的。因为在公司没写完就回来了，所以深夜还是继续写，当日事当日毕。 ETpl说说ETpl吧，一个百度模板引擎，虽然用到人不是很多，但是大致还是一样的吧 通用模板都是大致类似，一开始遇到的问题还是挺多的，因为模板在项目或者是组件都是很多封装或者是写好的，需要什么就哪来用，不过，多多少少还是会有问题的，比如兼容性或者是可能这个组件不适用今后的产品升级，那就需要更新这个组件，但是你会发现，组件是很多地方在通用，所以你很多东西你不能乱动的，就怕会牵一发而动全身。 但是这不是我要考虑的事情，我要做的就是把功能做好，或者做出来吧 现阶段。先熟悉熟悉框架或者是别人的代码，一开始没啥经验，也没比较全面的文档，或者是教程，很多都是需要你去看别人的代码或者是代码去运行了你才能懂这个功能到底是干嘛用的。刚开始前几天确实没头绪，蒙了，有点想放弃，但是想想别人大都是这么过来的，自己就是吃翔也得坚持下来对吧? ECUIECUI实现MVC的一些业务实现控件化，就是希望做到每个功能能够组件化吧。不过写组件的我都觉得很佩服，是我需要学习的前辈们。 入职第一天，我的导师—— 我的师傅，挺不错的，我见过的很勤奋的一个女前端，得叫全栈，因为他们都是Java转的前端，来抢前端的饭碗的女中豪杰，还有超哥和浩哥都是这里的一员。吃饭都是各成一派，我要是想吃面食就跟浩哥走，想吃盖饭啥的就跟超哥走。就是这么随波逐流，没办法。 一开始，需要知道的东西比较多，所以比较乱，毕竟从外包公司出来的，所以很多东西还是比较不规范需要去加强学习的。先来说说Git吧，耳熟能详的东西。 按照以往的做法，以往我们都是直接在Master提交代码，或者是SVN，那时候还不是命令那么高端，都是客户端可视化，所以直接更新或者是检出提交，所以总出现各种问题，在外包的时候，你需要跟着客户的节奏走，赶时间赶项目，时间一紧张就会频繁遇到问题。小项目还好，但是遇到大项目估计就不行了这种办法。 来了公司之后，开始熟悉下运作流程，提交代码都是各种需要权限，我自己建一个分支，然后开始开发了，每次提交代码都需要别人的代码审核或者叫review，没问题给你通过代码审核，你可能push成功上去，不行就给你打回去，你就需要重新git reset 到成功的那个版本（changeId） ，假如通过了，那还不一定就完事了，代码是使用Jenkins配置自动化构建，自动代码检查和压缩打包之类的，你得看是不是有报错，所以没问题才能继续通过SSH上传到开发环境。一开始我又蒙了，什么鬼啊这是？一直出问题，代码报错，因为你JS不书写规范或者是CSS 不书写规范都会构建不成功（比如function后面需要空格或者是改空格就空格，分号啥的都要按照书写规范，一开始有个功能用到Tab切换，我用到的时候闭包去写切换，然后又是报错，我实在没辙了），最后师傅叫我安装本地的JSSLint 和 CSSLint ，OK 安装就安装呗，没想到，又是遇到问题来了。我之前Sublime安装了各种插件，所以一直安装不成功，因为公司用的CSSLint 和 JSLint 的校验包都是有了，我需要用Node安装着两个，然后替换这两个文件夹，后台我把我心爱的插件都删了，重新安装了CSSLint 和 JSLint 就可以了，真是纠结死我了。 12345671.安装nodejs最新版本，通过nodejs指令 cmd下执行npm install -g xxx分别安装jslint与csslintnpm install -g jslintnpm install -g csslint2.安装Sublime Text 3(推荐，也可以安装别的工具)，安装Package Control3.通过Package Control安装SublimeLinter/SublimeLinter-contrib-jslint/SublimeLinter-csslint ctrl + shift + p---&amp;gt;install package4.执行jslint找到jslint的安装目录的父目录，使用我提供的jslint/csslint包覆盖掉原来的jslint与csslint 安装完这两个东西，把所有的文件报错都修改了 ，再Git命令push,review进行审核，哦哦，原来如此，不过真是折腾死宝宝 了(づ｡◕‿‿◕｡)づ 我不能放弃吃药才行！ Fiddler代理也是知道原来用这个来做前后端分离，假如后台是Java或者是项目是基于后台的Java 我就想到头疼的需要各种配置后台环境，用Fiddler 写正则判断，实现本地走代理，不过需要配置本地的HOST文件。 1regex:https://hyb628.github.io/(.*).(html|js|css|less|js_|jpg|png)(\?[a-zA-Z0-9]+=[0-9A-Za-z]*)?$ 这样我就把需要的资源就不走外网直接走本地，不过https链接本地打开的话每次都提示证书问题确实比价烦，需要把s去掉就好，第一次资源加载进来在打开代理加载规则，加上用用框架的，视图层 和 数据逻辑都分开配合使用，加上ECUI的路由addRoute 控制实现类似单页面的不刷新页面跳转差不多这个意思。也可以用callRoute调用路由，哦哦，原来这样啊。 前端交互之前一直没在做这块，所以，后端专心写他们的接口就好了，前端也不用去管他们用什么环境，前端该怎么开发就怎么开发，完全独立出来。各自负责自己的业务吧。 后台写好接口需要前后端联调，好吧，我确实没做过这块，所以，又得跟后台大哥去做配合联调，一开始可能他们写的接口有问题那就慢慢对接，我照样开发，我需要什么参数叫后台给我提供好，或者看需求文档，不过，需求文档这东西，要是产品经理写的没那么详细，那估计你又得去撩妹，找找她们说说哪里不行怎么做好了。也很费神。 需求文档包含埋点的增加，就是类似数据监控吧。我开发完才去加这些 不过还算简单，期间，PPT和PSD 都给到你了，不过PSD比较不好找，估计时间比较赶吧设计师，有点糙，不过也没事，反正我是切图仔，专业抠图20年（顺带抠脚）。 开发完一个功能，因为涉及到跟JSP的页面跳转，因为毕竟可能有些老代码的话那就不可能一下子都改革过来都是慢慢更新迭代，就涉及到比如页面的跳转，也是需要用路由的方式，发个请求跟JSP那个大哥协商好发什么东西给他我页面才能跳转到正确页面，也蛮有意思的。 SSH （Xshell）代码部署我通过Jenkins 构建成功的话，需要进行打包，因为一开始构建我遇到一直打包不成功的问题，后来各种找问题，才发现我的LESS文件里面import了其他功能的LESS ，导致那个文件编译了，我的LESS就被output 丢弃了。所以搞得我都直播吃翔了。一开始以为LESS书写不规范或者是哪里问题，各种修改，各种蛋疼，就取消嵌套规则，结果还是不行，后台请教了文浩大哥，他第二天早上去看了看打包工具的源码，才发现是我的import问题，删掉结果就成功了，那时候，感动的鼻涕鼻屎都快出来了（没那么夸张，有点夸张，就是比较激动吧）。 成功后，下载打包成功的代码包，准备部署到测试环境了，这下师傅跟我说你用Xshell工具进行部署，问我会不会LINUX的一些命令，我这下又懵逼了，我说不会，我说你演示我看看，我记一下，结果，上面很多文件夹还是有权限的，一开始给我部署时候，进行代码全部覆盖，其实我都看不懂，比较笨呗，最后，暗自下决心开始学习基本命令，因为Mac几个简单命令还是稍微知道，要是这种 .tar.gz 打包好，先rz命令上传文件包，上传然后用 -zxvf web-fe-XXXX.tar.gz ( Tab键可补全文件名) 解压文件，然后再改改一个配置文件，就好了，第二天，我做了笔记自己尝试了下，觉得还行，像文件的删除，移动，或者是解压命令用几次就熟悉啦。也就能实现自己去部署代码啦。 CO提测以前写代码，假如有测试人员，貌似都是后台部署然后测试进行测试吧，怎么测试我就不懂啦。现在需要做的就是进行提交测试申请，加入后端写接口的 他们也自己提交自己的测试申请，前端自己开发的提交自己Git分支的测试申请，通过网站，把构建好的源码包上传，还有需要写README文件，大致内容告诉测试人员提测点，需要测试哪些功能，他们好进行测试，还有就是你修改的哪些文件，这样他们测试的时候，直接抓取那个修改的文件过来就好，不至于整个项目进行替换，还有自己也写写备注自己修改了哪些文件，自己好知道。还有重要的一点就是，写提测点文件需要附上后台接口地址这样他们测试人员好对照接口进行测试，还有，因为埋点前端自己加，所以加了哪些也得提测前写到通用的线上文档里面，写完了测试申请说明和文件就提交上去啦，只是第一轮提测，期间测试人员通过禅道进行测试Bug反馈，不过，我拿到我的禅道账号打开一看，再次懵逼了，里面的项目多的我都找不到我的项目属于哪个，最后才知道我需要问问测试人员测试项目的版本号，每进行一个小功能测试都有测试版本号，加入这个版本号测试完了，你去修改Bug 改完了后继续提交第二轮测试，貌似好几轮测试。都不容易啊。~~(&gt;_&lt;)~~ 浅谈Bug说下遇到的一个之前没遇到过的Bug吧，就是tbody用JS的innerHTML插入，在IE9- 不支持，因为IE的只读模式所以出现未知的报错， 问题描述， 尝试后发现过于复杂并且不使用这个模板渲染方式，所以最后不得不换用li 标签之类的修改。加上模板引擎就不好做处理，所以需要谨慎用table标签吧。 涉及到的知识点有： 加入我用callRoute调用路由的方式进行页面的参数附带在浏览器上数据重新渲染，那还好，但是，我实现的是JS的重新渲染数据，所以这里就遇到瓶颈，纠结了一晚上最后还是决定改标签了。数据逻辑还是需要考虑全面一点才行。 今天例会，师傅老大说，看我现在手头项目也差不多好了，就说叫我下周开始学习React + Webpack ，新项目会用到吧，正好我也想研究点新东西加上项目实践。然后ECUI项目边弄吧。 明天团建得早起，2天时间得忙咯，貌似去北京郊外玩玩，顺带爬爬山。好久没去走走了，快枯萎了。晚安。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[古水北镇]]></title>
      <url>%2F2016%2F05%2F18%2F20160518%E5%8F%A4%E6%B0%B4%E5%8C%97%E9%95%87%2F</url>
      <content type="text"><![CDATA[快20天没唠叨了，本想今晚睡前说点啥或者写个技术总结啥的，但是无奈快要感冒似的 （估计刚抽完烟自我感觉有关系），下次再说来这里写吧。听首歌再去睡觉。 周末部门间要团建，所以到时候估计就有照片又可以更新了，昨天在Mac上面安装AE，打开速度很快的我快眼瞎了，所以就打算周末要是有好的照片啥的或者 周末回来弄个AE 刚好可以试试电脑渲速度。 [2016.5 更新] 古水北镇 &amp; 长城 浪去了~~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[路过厦门]]></title>
      <url>%2F2016%2F04%2F30%2F20160430%E9%9A%8F%E7%AC%94%2F</url>
      <content type="text"><![CDATA[本来打算五一在北京继续溜达，或者宅家里，然后跟家里通电话，就叫我回去了，顺带五一要扫墓，所以，没办法，深夜2点到机场，早上6点多的飞机到泉州晋江，一夜没睡，超级困。 到泉州，坐摩托到晋江火车站，然后就到厦门站，然后跟明锦去了海边溜达溜达就时间过得很快了。没那么多时间继续停留了。 回家后，发现，原本规划好的时间，你会发现每次都悄悄溜走了。明天就得去扫墓下，一天时间估计又要过去了。然后就要回北京了。又是各种忙碌。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[求display值的面试题分析]]></title>
      <url>%2F2016%2F04%2F09%2F%E6%B1%82display%E5%80%BC%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[题目是这样的： 一个空span标签被赋予下列属性时，对应的display计算值（compute value） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;style type="text/css"&gt; .span1&#123;color:#9999&#125; .span2&#123;float:left&#125; .span3&#123;position:relative&#125; .span4&#123;position:absolute&#125; .span5&#123;visibility:none&#125; .span6&#123;display:-webkit-grid;float:left&#125; .span7&#123;display:inline-table;float:left&#125; .span8&#123;display:inline-block;float:left&#125; .span9&#123;display:inline-flex;float:left&#125; .span10&#123;display:flex;float:left&#125; .span11&#123;display:-webkit-grid&#125; .span12&#123;display:flex&#125; &lt;/style&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 填写当一个无样式的空span被赋予下列属性时 --&gt; &lt;span class="span1"&gt;1、color: #9999;&lt;/span&gt; &lt;span class="span2"&gt;2、float: left; &lt;/span&gt; &lt;span class="span3"&gt;3、position: relative;&lt;/span&gt; &lt;span class="span4"&gt;4、position: absolute;&lt;/span&gt; &lt;span class="span5"&gt;5、visibility: none;&lt;/span&gt; &lt;span class="span6"&gt;6、display: -webkit-grid;float:left;&lt;/span&gt; &lt;span class="span7"&gt;7、display: inline-table;float: left;&lt;/span&gt; &lt;span class="span8"&gt;8、display:inline-block;float:left;&lt;/span&gt; &lt;span class="span9"&gt;9、display:inline-flex;float:left;&lt;/span&gt; &lt;span class="span10"&gt;10、display:flex;float:left;&lt;/span&gt; &lt;span class="span11"&gt;11、display:-webkit-grid&lt;/span&gt; &lt;span class="span12"&gt;12、display:flex&lt;/span&gt; &lt;script&gt; var spans = document.getElementsByTagName('span'); function getStyle(element, proName)&#123; var eleStyle; if(!document.defaultView)&#123; eleStyle = element.currentStyle[proName]; &#125; else &#123; eleStyle = document.defaultView.getComputedStyle(element)[proName]; &#125; return eleStyle; &#125; for (var i = 0; i &lt; spans.length; i++) &#123; console.log(spans[i].innerHTML + '获取到的display结果为：' + getStyle(spans[i],'display')); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： 123456789101112color: #9999;获取到的display结果为：inlinefloat: left; 获取到的display结果为：blockposition: relative;获取到的display结果为：inlineposition: absolute;获取到的display结果为：blockvisibility: none;获取到的display结果为：inlinedisplay: -webkit-grid;float:left;获取到的display结果为：blockdisplay: inline-table;float: left;获取到的display结果为：tabledisplay:inline-block;float:left;获取到的display结果为：blockdisplay:inline-flex;float:left;获取到的display结果为：flexdisplay:flex;float:left;获取到的display结果为：flexdisplay:-webkit-grid获取到的display结果为：inlinedisplay:flex获取到的display结果为：flex 其实重点还是我加粗的这两个结果，因为之前自己的理解table标签是块元素 所以想到的就是display:table;之后加上float:left;应该是block的结果呈现猜对 不过还是不对，答案运行出来还是很意外。 所以还是不明白为什么这样，因为我换做display:table-cell;（类似table中的td），float:left;一起，结果是block； MDN上面的解释还是没说到我想要的答案，但是找了一对资料还是没明白清楚，于是，找到 CSS-Tricks上面一个老外的回复说 如果display:table;或者是display:inline-table;和float:left；一起的话，默认是优先级为table。测试的过程中只有table/inline-table 与float 或者是 flex / inline-flex 与float 结合的时候才优先 取得diaplay值为table或者是flex; 其实float 换做position: absolute; 其实跟float一样都是脱离文档流的。 flex是弹性布局，table布局的时候，结合table-cell 一起效果就能看出，所以table用来实现水平垂直居中，你的table-cell 不用设置宽高，自己会默认赋予。 理解的不够透彻吧~ 不过还是希望理解的小伙伴给予说明，不胜感谢。或者是具体是吗办法来理解比较专业？]]></content>
    </entry>

    
  
  
</search>
