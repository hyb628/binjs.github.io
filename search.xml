<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[ES6的Array.from、Set数组去重]]></title>
      <url>%2F2016%2F09%2F14%2FES6%E7%9A%84Array.from%E3%80%81Set%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
      <content type="text"><![CDATA[Set数据结构ES6中新增了Set数据结构，类似于数组，但是 它的成员都是唯一的 ，其构造函数可以接受一个数组作为参数，如： 1234let array = [1, 1, 1, 1, 2, 3, 4, 4, 5, 3];let set = new Set(array);console.log(set);// =&gt; Set &#123;1, 2, 3, 4, 5&#125; Array.fromES6中Array新增了一个静态方法Array.from，可以把类似数组的对象转换为数组，如通过querySelectAll方法得到HTML DOM Node List，以及ES6中新增的Set和Map等可遍历对象，如： 1234let set = new Set();set.add(1).add(2).add(3);let array = Array.from(set);console.log(array); // [1, 2, 3] 于是，现在我们可以用一行代码实现数组去重了：于是，现在我们可以用一行代码实现数组去重了: 12let array = Array.from(new Set([1, 1, 1, 2, 3, 2, 4]));console.log(array); //[1, 2, 3, 4]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阶段性技术啰嗦（二）]]></title>
      <url>%2F2016%2F09%2F03%2F%E9%98%B6%E6%AE%B5%E6%80%A7%E6%8A%80%E6%9C%AF%E5%95%B0%E5%97%A62%2F</url>
      <content type="text"><![CDATA[记得上次阶段性啰嗦是在5月份，转眼间，就到九月了，时间过的好快，又过得好漫长，两点一线的生活，充实的生活，也懒到了一定的境界，甚是乏累。今天公司网络升级改造，所以早早就回来，就想起写点啥，虽然经验少，肚子里没墨水也想挣扎一番。Let me see ! 说下最近都在忙啥吧：七月份开始一直到现在一直在弄Approve项目，推迟了上线时间，因为尝试用了React新框架，遇到的问题也挺多了，禅道的Bug可真不是一般的多的。所以，一直解决Bug中。负责这个项目的我们三个人就这么Coding。说到底，项目逻辑的复杂度不是一般的复杂。刚毕业那会工作，主要前端开发的一般偏向UI方面，所以，交互，数据方面一般处理的比较少甚至基本都是交于后端处理，这方面比较薄弱，经过以前的面试洗礼，有个面试官说，我们只要做JS交互方面的，才下定决心一定要坚持在这方向努力学习才行。不过，也很感叹，一开始以为切切图的码畜，原来常挂嘴里的切图，自从遇到了公司了一位设计转UI切图的资深女同事才发现，原来切图人家真的到了一定的境界，让我好生佩服。 说说最近的一些问题：刚开始我们老大说项目重构，要用React，所以，很正常，很多人肯定没接触了，都要从0开始，毕竟，在Ag横行的年代，也是还是有一些牛逼的技术栈并行。记得6月份就说要用了，然后自己也看了FB官网的API，东西也不多，但是，React 只是负责V层面上的东西，伴随它有用的东西就一个state和props, 以及一些生命周期，在React中，数据的流向是单向的，基于react + redux的模式开发配合着ES6（ES6很多东西写着确实不错，就那么些，Babel就帮你搞定了，加上Webpack可以把你代码转为兼容低版本的ES3或者是ES5之类的代码）就这么孕育而生。 Redux 官网1231. store 是应用的状态管理中心，保存着是应用的状态（state），当收到状态的更新时，会触发视觉组件进行更新。2. container 是视觉组件的容器，负责把传入的状态变量渲染成视觉组件，在浏览器显示出来。3. reducer 是动作(action)的处理中心， 负责处理各种动作并产生新的状态（state），返回给store。 nvm Github我Mac是直接用了nvm进行node版本的控制，切换node版本的时候 是直接 nvm use 6.2.1 或者是 nvm use 4.4.5 之类的不同版本切换，如果需要用到的情况下。不过也有其他东西类似的版本控制。 ES6历时将近6年的时间来制定的新 ECMAScript 标准 ECMAScript 6（亦称 ECMAScript Harmony，简称 ES6）终于在 2015 年 6 月正式发布。自从上一个标准版本 ES5 在 2009 年发布以后，ES6 就一直以新语法、新特性的优越性吸引著众多 JavaScript 开发者，驱使他们积极尝鲜。 阮一峰的《ECMAScript 6 入门》InfoQ上的 《深入浅出ES6》 一般都是都是看这两个 比较全， 不过一般用到才去看下或者查下，一般常用的就是箭头函数，或者是解构或者是新增加的一些方法，比较方便，比如Object.assign() 项目里也用的比较多， 12Object.assign(target, ...sources)Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。 直接戳MDN 类似的字符串模板也不过 比如：1234const names = `一喵呜`;console.log(`$&#123;names&#125; binjs.com`);result: 一喵呜 binjs.com 12345Spread： export function getSelCCuser(options) &#123; const &#123; approveId, ...others &#125; = options; return httpUtil.post(`/api/approve/w1/approves/$&#123;approveId&#125;/cc`, &#123;...others&#125; );&#125; 12const &#123; detail, name &#125; = this,propsconst &#123; names &#125; = this.state 还有比如，项目遇到一个前端模糊搜索匹配问题，想到正则比较麻烦，还好，想到ES6有includes() 这个东西，一切就好办了。 之类的 等等，还是不错的。 Ant-Design 官网项目UI基于蚂蚁金服的ant进行组件开发，项目里需要用到一个抽屉组件，一开始，真不知道怎么搞，不过，最后不知道怎么纠结，最后，把抽屉小组件写了整合进ant项目里，发布到npm，供以后公司项目其他项目模块重构可以服用，不过蚂蚁金服确实很赞，但是还是也还是遇到很多问题，真的操碎心。 这几天，发现基于React Nactive的mobile ant组件出来了，虽然没用过不过还是很好奇的。Mobile官网 之前Leader说一人写几个组件，然后因为组件要整合的太多，因为React都是很多一个个小组件，UI样式也没，最后就直接用蚂蚁金服这个来复用开发，还有类似的很多 比如： Amaze-UI ， Material-UI，但后面这两个确实不行。哈。 React 组件间的通信，纯粹自己理解就是：121. 父级 --&gt; 子级 ： props2. 子级 --&gt; 父级： callback lodash 官网Approve项目还引入了一个工具库，算是对JS的一个扩充吧。有些API用着还是不错的。 PromisePromise这个水好深，反正现在就是我只知道的理解就是异步的处理 ，then的类似回调。不过看了这篇文章还是太难过了。比较稚嫩 ， 抽根烟先去睡觉。后面好好学习。 再做补充。 保存个书签：Promise迷你书（中文版）[翻译] We have a problem with promises]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[随笔 2016-08-6]]></title>
      <url>%2F2016%2F08%2F06%2F20160806%E9%9A%8F%E7%AC%94%2F</url>
      <content type="text"><![CDATA[深夜，又是一个周末，难得这个周末啥都断想，啥都不管，就这么放空。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SASS用法小记]]></title>
      <url>%2F2016%2F06%2F18%2FSASS%E7%94%A8%E6%B3%95%E5%B0%8F%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[之前项目用LESS，现在新项目打算用SASS，所以做个主要常用知识点小记。 在线编译地址@import 引入12 @import &quot;../binjs.scss&quot;; // 引入文件 @import &quot;../huangyb.css&quot;; @mixin 混入 注意：LESS的变量用@ , SASS是 $ 带参数 1234567@mixin borderSet($dott: solid, $color: #fcf) &#123; border: 8px $dott $color;&#125;div &#123; opacity: 0; @include borderSet(dotted, #fa0); //带参数传入&#125; 不带参数 显示默认值 不定义参数值 就显示默认值 1234567@mixin borderSet($dott: solid, $color: #fcf) &#123; border: 8px $dott $color;&#125;div &#123; opacity: 0; @include borderSet; //不带参数传入 可括号 可不括号&#125; 嵌套 LESS也是一样的嵌套规则， &amp; 符号都相同 使用&amp;引用父元素 1234567div &#123; opacity: 0; @include borderSet(); //不带参数传入 可括号 可不括号 &amp;:after &#123; color:#ccc; &#125; &#125; 属性的嵌套 123456 p &#123; border: &#123; color:red; width:12px; &#125;&#125; 变量用 #{} 包裹如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。一般来说，我们设置的变量都是用于属性值的，而如果用在属性或者选择器上，就得以#{}包裹起来了。 123456789$className:huangyb;.#&#123;$className&#125; &#123; width: 12px;&#125;// 解析成.huangyb &#123; width: 12px;&#125; 12345678$side : left;.#&#123;$side&#125; &#123; border-#&#123;$side&#125;-radius: 5px;&#125;// 解析成.left &#123; border-left-radius: 5px;&#125; !default 的使用正常情况下 声明两个变量 会出现后面覆盖前面的变量12345$color:red;$color:blue;p&#123; color:$color; //blue&#125; 若声明了 !default 会就不能出现覆盖的现象 12345$color:red;$color:blue !default;p&#123; color:$color; //red&#125; 多个变量的声明12345678910111213141516$linkColor: red blue;a&#123; color:nth($linkColor,1); &amp;:hover&#123; color:nth($linkColor,2); &#125;&#125;// 解析后a &#123; color: red;&#125;a:hover &#123; color: blue;&#125; @extend 继承1234567891011121314151617181920div &#123; color:#fcf; &#125;p &#123; @extend div; width:10px; &#125;span &#123; @extend p;&#125;// 解析后div, p, span &#123; color: #fcf;&#125;p, span &#123; width: 10px;&#125; function123456789101112@function binjs($value) &#123; @return #&#123;$value&#125;px;&#125;div &#123; width: binjs(30);&#125;//解析后div &#123; width: 30px;&#125; @if @else 条件判断12345678$width:12px;div &#123; @if ($width&gt;10) &#123; color:#fcf; &#125; @else &#123; color:#fa0;; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6数组的扩展]]></title>
      <url>%2F2016%2F06%2F13%2FES6%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
      <content type="text"><![CDATA[今天培训了,只能自己看这些东西啦。一天时间又过去了。现在文章，或者我的印象笔记都是采用Markdown 来写了， 是不是看起来比较整洁了。有点想改用Hexo, 看着很不错，markdown 也写得比较有意思 貌似。 一直想弄 ，但是又怕麻烦。 Array.from1234567891011121314let arrayLike = &#123; &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]等同于：var arr1 = Array.prototype.slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]// ES6的写法let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 查看之前文章Array.prototype.slice.call介绍 不过，对象数组的写法需要严格按照规范写，比如：1234var foo = &#123;0:&apos;hello&apos;,1:&apos;world&apos;,length:4&#125;;Array.prototype.slice.call(foo); // [&quot;hello&quot;, &quot;world&quot;, undefined × 2]Array.from(arrayLike); // [&quot;hello&quot;, &quot;world&quot;, undefined, undefined] Array.from() 的第一个参数决定第二个参数的执行次数， 12Array.from(&#123; length: 3 &#125;); // [undefined, undefined, undefinded]Array.from(&#123;length:3&#125;,() =&gt;&apos;binjs&apos;); // [&apos;binjs&apos;, &apos;binjs&apos;, &apos;binjs&apos;] Array.from() 还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] 只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。1234Array.from(&apos;hello&apos;); // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;]let namesSet = new Set([&apos;a&apos;, &apos;b&apos;]);Array.from(namesSet); // [&apos;a&apos;, &apos;b&apos;] Array.of方法用于将一组值，转换为数组。 1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] includes与字符串的includes方法类似1[1,2,3].includes(1); // true ind() 和 findIndex()find() 返回数组中满足测试条件的一个元素，如果没有满足条件的元素，则返回 undefined。 1[1, 4, -5, 10].find((n) =&gt; n &lt; 0) find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 12345[1, 3, 5].find(function(value, index, arr) &#123; console.log(value); console.log(index); console.log(arr); &#125;) findIndex() 用来查找指定的索引，如果找不到指定的元素, 则返回 -1 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 fill()fill() 用来进行数组的填充 ，第二和第三个参数表示开始和结束位置 12[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 0, 1) //[7, &quot;b&quot;, &quot;c&quot;][&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 0, 2) // [7, 7, &quot;c&quot;] fill() 可以用来初始化一个数组 12345[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6数值的扩展]]></title>
      <url>%2F2016%2F06%2F12%2FES6%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
      <content type="text"><![CDATA[数值的扩展ES6提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 120b111110111 === 503 // true0o767 === 503 // true 转为十进制的方法 使用Number： 12Number(&apos;0b111&apos;) // 7Number(&apos;0o10&apos;) // 8 Number.isFinite()用来检测传入的参数是否是一个有穷数。和全局的 isFinite() 函数相比，这个方法不会强制将一个非数字的参数转换成数字，这就意味着，只有真正的数字才有可能返回 true。 1234567891011Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite(&apos;foo&apos;); // falseNumber.isFinite(&apos;15&apos;); // falseNumber.isFinite(true); // falseNumber.isFinite(0); // trueNumber.isFinite(2e64); // trueNumber.isFinite(&apos;0&apos;); // false, 全局函数 isFinite(&apos;0&apos;) 会返回 true Number.isNaN()用来检查一个值是否为NaN。 这两个新方法只对数值有效，非数值一律返回false。 123456789isFinite(25) // trueisFinite(&quot;25&quot;) // trueNumber.isFinite(25) // trueNumber.isFinite(&quot;25&quot;) // falseisNaN(NaN) // trueisNaN(&quot;NaN&quot;) // trueNumber.isNaN(NaN) // trueNumber.isNaN(&quot;NaN&quot;) // false Number.parseInt(), Number.parseFloat()ES6 将全局的parseInt 和 parseFloat移植到Number对象上 Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3 与 3.0 || 3.00 被视为同一个值。 12345Number.isInteger(25) // trueNumber.isInteger(25.0) // trueNumber.isInteger(25.1) // falseNumber.isInteger(&quot;15&quot;) // falseNumber.isInteger(true) // false Number.EPSILON 常量ES6在Number对象上面，新增一个极小的常量Number.EPSILON。 引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。 123456780.1 + 0.2// 0.300000000000000040.1 + 0.2 - 0.3// 5.551115123125783e-175.551115123125783e-17.toFixed(20)// &apos;0.00000000000000005551&apos; 但是如果这个误差能够小于Number.EPSILON，我们就可以认为得到了正确结果。 15.551115123125783e-17 &lt; Number.EPSILON // true Math对象的扩展Math.trunc()用于去除一个数的小数部分，返回整数部分 123456Math.trunc(4.1) // 4Math.trunc(4.9) // 4Math.trunc(-4.1) // -4Math.trunc(-4.9) // -4Math.trunc(-0.1234) // -0Math.trunc(&apos;123.456&apos;) // 123 对于空值和无法截取整数的值，返回NaN。 1234Math.trunc(NaN); // NaNMath.trunc(&apos;foo&apos;); // NaNMath.trunc(); // NaNMath.trunc(&apos;123a.456&apos;) // NaN Math.sign()用来判断一个数到底是正数、负数、还是零。 参数为正数，返回+1；参数为负数，返回-1；参数为0，返回0；参数为-0，返回-0;其他值，返回NaN。 1234567Math.sign(-5) // -1Math.sign(5) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(NaN) // NaNMath.sign(&apos;foo&apos;); // NaNMath.sign(); // NaN]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6解构赋值]]></title>
      <url>%2F2016%2F06%2F11%2FES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
      <content type="text"><![CDATA[配置文件.babelrcBabel的配置文件是.babelrc，存放在项目的根目录下。使用Babel的第一步，就是配置这个文件。 ES草案阶段 Stage 0 - Strawman（展示阶段） Stage 1 - Proposal（征求意见阶段） Stage 2 - Draft（草案阶段） Stage 3 - Candidate（候选人阶段） Stage 4 - Finished（定案阶段） let和const 命令let不像var那样会发生“变量提升”现象（就是var 定义了 然后输出undefined，let 直接报错 ）。所以，变量一定要在声明后使用，否则报错。 ES6的块级作用域let实际上为JavaScript新增了块级作用域。 块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。1234567891011// IIFE写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 下面的代码如果使用var 输出的是 101234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123;a[i] = function () &#123; console.log(i);&#125;;&#125;a[6](); // 6 不存在变量提let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。 变量不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 解构赋值直接赋值1var [a, b, c] = [1, 2, 3]; Set 赋值1let [x, y, z] = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]); 默认值如果一个数组成员不严格等于undefined，默认值是不会生效的。12let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined];console.log(x,y) 如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。12345var [x = 1] = [undefined];x // 1var [x = 1] = [null];x // null 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 对象的解构赋值1var &#123; foo: foo, bar: bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;; 对象的解构也可以指定默认值。123456789var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123; message: msg = &quot;Something went wrong&quot; &#125; = &#123;&#125;;msg // &quot;Something went wrong&quot; 现有对象方法赋值到某个变量 1let &#123; log, sin, cos &#125; = Math; 解析出来的结果类似 代码1234&quot;use strict&quot;;var log = Math.log;var sin = Math.sin;var cos = Math.cos; 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。123456const [a, b, c, d, e] = &apos;hello&apos;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot; 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 12let &#123;length : len&#125; = &apos;hello&apos;;len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 函数参数的解构赋值1234function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 解构赋值用途交换变量的值1[x, y] = [y, x]; 从函数返回多个值1234567891011121314// 返回一个数组function example() &#123; return [1, 2, 3];&#125;var [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;var &#123; foo, bar &#125; = example(); 函数参数的定义1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据12345678910var jsonData = &#123;id: 42,status: &quot;OK&quot;,data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309] 遍历Map结构123456789var map = new Map();map.set(&apos;first&apos;, &apos;hello&apos;);map.set(&apos;second&apos;, &apos;world&apos;);for (let [key, value] of map) &#123;console.log(key + &quot; is &quot; + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 123456789// 获取键名for (let [key] of map) &#123;// ...&#125;// 获取键值for (let [,value] of map) &#123;// ...&#125; 字符串的扩展传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。 includes()返回布尔值，表示是否找到了参数字符串。 12345var s = &apos;Hello world!&apos;;if(s.includes(&apos;ld&apos;)) &#123; console.log(1)&#125; startsWith()返回布尔值，表示参数字符串是否在源字符串的头部。 1s.endsWith(&apos;!&apos;) // true endsWith()返回布尔值，表示参数字符串是否在源字符串的尾部。 1s.endsWith(&apos;!&apos;) // true 这三个方法都支持第二个参数，表示开始搜索的位置。 12345const s = &apos;Hello world!&apos;;s.startsWith(&apos;world&apos;, 6) // trues.endsWith(&apos;Hello&apos;, 5); // trues.endsWith(&apos;Hell&apos;, 4); // trues.includes(&apos;Hello&apos;, 6) // false 字符串模板123// 字符串中嵌入变量let name = &quot;Bob&quot;, time = &quot;today&quot;;console.log(`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`) 模板字符串都是用 `, 也可以用来调用函数 1234function add() &#123; console.log(1222);&#125;let str = `Nihai $&#123;add()&#125;`;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阶段性技术啰嗦（一）]]></title>
      <url>%2F2016%2F05%2F20%2F%E9%98%B6%E6%AE%B5%E6%80%A7%E6%8A%80%E6%9C%AF%E5%95%B0%E5%97%A61%2F</url>
      <content type="text"><![CDATA[听听有情怀的歌，陶冶情操！大学很爱的一首歌。 又到周五了，趁现在下班时间，抽空写写最近在公司遇到的坑以及学到的东西吧，最近一直很少做自己的技术总结，老是写生活随笔啥的似乎也不符合我这个愤青的年龄 。看到我都觉得我活在小康社会似的，我都快不相信自己了。 最近一直在做支付项目，公司用到了百度ECUI的一个MVC框架，配合ETpl模板引擎，后台是Java语言，开始做前后端分离 毕竟第一次做，难免有些紧张。(~.~)，讲讲几个遇到的问题以及解决办法吧，俗话说，找到合适的途径 合适的方法才是做重要的。因为在公司没写完就回来了，所以深夜还是继续写，当日事当日毕。 ETpl说说ETpl吧，一个百度模板引擎，虽然用到人不是很多，但是大致还是一样的吧 通用模板都是大致类似，一开始遇到的问题还是挺多的，因为模板在项目或者是组件都是很多封装或者是写好的，需要什么就哪来用，不过，多多少少还是会有问题的，比如兼容性或者是可能这个组件不适用今后的产品升级，那就需要更新这个组件，但是你会发现，组件是很多地方在通用，所以你很多东西你不能乱动的，就怕会牵一发而动全身。 但是这不是我要考虑的事情，我要做的就是把功能做好，或者做出来吧 现阶段。先熟悉熟悉框架或者是别人的代码，一开始没啥经验，也没比较全面的文档，或者是教程，很多都是需要你去看别人的代码或者是代码去运行了你才能懂这个功能到底是干嘛用的。刚开始前几天确实没头绪，蒙了，有点想放弃，但是想想别人大都是这么过来的，自己就是吃翔也得坚持下来对吧? ECUIECUI实现MVC的一些业务实现控件化，就是希望做到每个功能能够组件化吧。不过写组件的我都觉得很佩服，是我需要学习的前辈们。 入职第一天，我的导师—— 我的师傅，挺不错的，我见过的很勤奋的一个女前端，得叫全栈，因为他们都是Java转的前端，来抢前端的饭碗的女中豪杰，还有超哥和浩哥都是这里的一员。吃饭都是各成一派，我要是想吃面食就跟浩哥走，想吃盖饭啥的就跟超哥走。就是这么随波逐流，没办法。 一开始，需要知道的东西比较多，所以比较乱，毕竟从外包公司出来的，所以很多东西还是比较不规范需要去加强学习的。先来说说Git吧，耳熟能详的东西。 按照以往的做法，以往我们都是直接在Master提交代码，或者是SVN，那时候还不是命令那么高端，都是客户端可视化，所以直接更新或者是检出提交，所以总出现各种问题，在外包的时候，你需要跟着客户的节奏走，赶时间赶项目，时间一紧张就会频繁遇到问题。小项目还好，但是遇到大项目估计就不行了这种办法。 来了公司之后，开始熟悉下运作流程，提交代码都是各种需要权限，我自己建一个分支，然后开始开发了，每次提交代码都需要别人的代码审核或者叫review，没问题给你通过代码审核，你可能push成功上去，不行就给你打回去，你就需要重新git reset 到成功的那个版本（changeId） ，假如通过了，那还不一定就完事了，代码是使用Jenkins配置自动化构建，自动代码检查和压缩打包之类的，你得看是不是有报错，所以没问题才能继续通过SSH上传到开发环境。一开始我又蒙了，什么鬼啊这是？一直出问题，代码报错，因为你JS不书写规范或者是CSS 不书写规范都会构建不成功（比如function后面需要空格或者是改空格就空格，分号啥的都要按照书写规范，一开始有个功能用到Tab切换，我用到的时候闭包去写切换，然后又是报错，我实在没辙了），最后师傅叫我安装本地的JSSLint 和 CSSLint ，OK 安装就安装呗，没想到，又是遇到问题来了。我之前Sublime安装了各种插件，所以一直安装不成功，因为公司用的CSSLint 和 JSLint 的校验包都是有了，我需要用Node安装着两个，然后替换这两个文件夹，后台我把我心爱的插件都删了，重新安装了CSSLint 和 JSLint 就可以了，真是纠结死我了。 12345671.安装nodejs最新版本，通过nodejs指令 cmd下执行npm install -g xxx分别安装jslint与csslintnpm install -g jslintnpm install -g csslint2.安装Sublime Text 3(推荐，也可以安装别的工具)，安装Package Control3.通过Package Control安装SublimeLinter/SublimeLinter-contrib-jslint/SublimeLinter-csslint ctrl + shift + p---&amp;gt;install package4.执行jslint找到jslint的安装目录的父目录，使用我提供的jslint/csslint包覆盖掉原来的jslint与csslint 安装完这两个东西，把所有的文件报错都修改了 ，再Git命令push,review进行审核，哦哦，原来如此，不过真是折腾死宝宝 了(づ｡◕‿‿◕｡)づ 我不能放弃吃药才行！ Fiddler代理也是知道原来用这个来做前后端分离，假如后台是Java或者是项目是基于后台的Java 我就想到头疼的需要各种配置后台环境，用Fiddler 写正则判断，实现本地走代理，不过需要配置本地的HOST文件。 1regex:https://hyb628.github.io/(.*).(html|js|css|less|js_|jpg|png)(\?[a-zA-Z0-9]+=[0-9A-Za-z]*)?$ 这样我就把需要的资源就不走外网直接走本地，不过https链接本地打开的话每次都提示证书问题确实比价烦，需要把s去掉就好，第一次资源加载进来在打开代理加载规则，加上用用框架的，视图层 和 数据逻辑都分开配合使用，加上ECUI的路由addRoute 控制实现类似单页面的不刷新页面跳转差不多这个意思。也可以用callRoute调用路由，哦哦，原来这样啊。 前端交互之前一直没在做这块，所以，后端专心写他们的接口就好了，前端也不用去管他们用什么环境，前端该怎么开发就怎么开发，完全独立出来。各自负责自己的业务吧。 后台写好接口需要前后端联调，好吧，我确实没做过这块，所以，又得跟后台大哥去做配合联调，一开始可能他们写的接口有问题那就慢慢对接，我照样开发，我需要什么参数叫后台给我提供好，或者看需求文档，不过，需求文档这东西，要是产品经理写的没那么详细，那估计你又得去撩妹，找找她们说说哪里不行怎么做好了。也很费神。 需求文档包含埋点的增加，就是类似数据监控吧。我开发完才去加这些 不过还算简单，期间，PPT和PSD 都给到你了，不过PSD比较不好找，估计时间比较赶吧设计师，有点糙，不过也没事，反正我是切图仔，专业抠图20年（顺带抠脚）。 开发完一个功能，因为涉及到跟JSP的页面跳转，因为毕竟可能有些老代码的话那就不可能一下子都改革过来都是慢慢更新迭代，就涉及到比如页面的跳转，也是需要用路由的方式，发个请求跟JSP那个大哥协商好发什么东西给他我页面才能跳转到正确页面，也蛮有意思的。 SSH （Xshell）代码部署我通过Jenkins 构建成功的话，需要进行打包，因为一开始构建我遇到一直打包不成功的问题，后来各种找问题，才发现我的LESS文件里面import了其他功能的LESS ，导致那个文件编译了，我的LESS就被output 丢弃了。所以搞得我都直播吃翔了。一开始以为LESS书写不规范或者是哪里问题，各种修改，各种蛋疼，就取消嵌套规则，结果还是不行，后台请教了文浩大哥，他第二天早上去看了看打包工具的源码，才发现是我的import问题，删掉结果就成功了，那时候，感动的鼻涕鼻屎都快出来了（没那么夸张，有点夸张，就是比较激动吧）。 成功后，下载打包成功的代码包，准备部署到测试环境了，这下师傅跟我说你用Xshell工具进行部署，问我会不会LINUX的一些命令，我这下又懵逼了，我说不会，我说你演示我看看，我记一下，结果，上面很多文件夹还是有权限的，一开始给我部署时候，进行代码全部覆盖，其实我都看不懂，比较笨呗，最后，暗自下决心开始学习基本命令，因为Mac几个简单命令还是稍微知道，要是这种 .tar.gz 打包好，先rz命令上传文件包，上传然后用 -zxvf web-fe-XXXX.tar.gz ( Tab键可补全文件名) 解压文件，然后再改改一个配置文件，就好了，第二天，我做了笔记自己尝试了下，觉得还行，像文件的删除，移动，或者是解压命令用几次就熟悉啦。也就能实现自己去部署代码啦。 CO提测以前写代码，假如有测试人员，貌似都是后台部署然后测试进行测试吧，怎么测试我就不懂啦。现在需要做的就是进行提交测试申请，加入后端写接口的 他们也自己提交自己的测试申请，前端自己开发的提交自己Git分支的测试申请，通过网站，把构建好的源码包上传，还有需要写README文件，大致内容告诉测试人员提测点，需要测试哪些功能，他们好进行测试，还有就是你修改的哪些文件，这样他们测试的时候，直接抓取那个修改的文件过来就好，不至于整个项目进行替换，还有自己也写写备注自己修改了哪些文件，自己好知道。还有重要的一点就是，写提测点文件需要附上后台接口地址这样他们测试人员好对照接口进行测试，还有，因为埋点前端自己加，所以加了哪些也得提测前写到通用的线上文档里面，写完了测试申请说明和文件就提交上去啦，只是第一轮提测，期间测试人员通过禅道进行测试Bug反馈，不过，我拿到我的禅道账号打开一看，再次懵逼了，里面的项目多的我都找不到我的项目属于哪个，最后才知道我需要问问测试人员测试项目的版本号，每进行一个小功能测试都有测试版本号，加入这个版本号测试完了，你去修改Bug 改完了后继续提交第二轮测试，貌似好几轮测试。都不容易啊。~~(&gt;_&lt;)~~ 浅谈Bug说下遇到的一个之前没遇到过的Bug吧，就是tbody用JS的innerHTML插入，在IE9- 不支持，因为IE的只读模式所以出现未知的报错， 问题描述， 尝试后发现过于复杂并且不使用这个模板渲染方式，所以最后不得不换用li 标签之类的修改。加上模板引擎就不好做处理，所以需要谨慎用table标签吧。 涉及到的知识点有： 加入我用callRoute调用路由的方式进行页面的参数附带在浏览器上数据重新渲染，那还好，但是，我实现的是JS的重新渲染数据，所以这里就遇到瓶颈，纠结了一晚上最后还是决定改标签了。数据逻辑还是需要考虑全面一点才行。 今天例会，师傅老大说，看我现在手头项目也差不多好了，就说叫我下周开始学习React + Webpack ，新项目会用到吧，正好我也想研究点新东西加上项目实践。然后ECUI项目边弄吧。 明天团建得早起，2天时间得忙咯，貌似去北京郊外玩玩，顺带爬爬山。好久没去走走了，快枯萎了。晚安。]]></content>
    </entry>

    
  
  
</search>
